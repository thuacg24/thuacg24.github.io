(function(){"use strict";/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Gi="170",Kr="attached",ih="detached",jr="",Ft="srgb",to="srgb-linear",eo="linear",pn="srgb";class $i{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const s=this._listeners[t];if(s!==void 0){const n=s.indexOf(e);n!==-1&&s.splice(n,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const i=this._listeners[t.type];if(i!==void 0){t.target=this;const s=i.slice(0);for(let n=0,r=s.length;n<r;n++)s[n].call(this,t);t.target=null}}}const ft=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],Xi=Math.PI/180,dn=180/Math.PI;function kt(){const h=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(ft[h&255]+ft[h>>8&255]+ft[h>>16&255]+ft[h>>24&255]+"-"+ft[t&255]+ft[t>>8&255]+"-"+ft[t>>16&15|64]+ft[t>>24&255]+"-"+ft[e&63|128]+ft[e>>8&255]+"-"+ft[e>>16&255]+ft[e>>24&255]+ft[i&255]+ft[i>>8&255]+ft[i>>16&255]+ft[i>>24&255]).toLowerCase()}function rt(h,t,e){return Math.max(t,Math.min(e,h))}function sh(h,t){return(h%t+t)%t}function mn(h,t,e){return(1-e)*h+e*t}function Vt(h,t){switch(t.constructor){case Float32Array:return h;case Uint32Array:return h/4294967295;case Uint16Array:return h/65535;case Uint8Array:return h/255;case Int32Array:return Math.max(h/2147483647,-1);case Int16Array:return Math.max(h/32767,-1);case Int8Array:return Math.max(h/127,-1);default:throw new Error("Invalid component type.")}}function J(h,t){switch(t.constructor){case Float32Array:return h;case Uint32Array:return Math.round(h*4294967295);case Uint16Array:return Math.round(h*65535);case Uint8Array:return Math.round(h*255);case Int32Array:return Math.round(h*2147483647);case Int16Array:return Math.round(h*32767);case Int8Array:return Math.round(h*127);default:throw new Error("Invalid component type.")}}class P{constructor(t=0,e=0){P.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(rt(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),n=this.x-t.x,r=this.y-t.y;return this.x=n*i-r*s+t.x,this.y=n*s+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Ut{constructor(t,e,i,s,n,r,o,a,c){Ut.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,i,s,n,r,o,a,c)}set(t,e,i,s,n,r,o,a,c){const l=this.elements;return l[0]=t,l[1]=s,l[2]=o,l[3]=e,l[4]=n,l[5]=a,l[6]=i,l[7]=r,l[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],o=i[3],a=i[6],c=i[1],l=i[4],f=i[7],u=i[2],p=i[5],d=i[8],y=s[0],m=s[3],x=s[6],g=s[1],w=s[4],b=s[7],v=s[2],S=s[5],A=s[8];return n[0]=r*y+o*g+a*v,n[3]=r*m+o*w+a*S,n[6]=r*x+o*b+a*A,n[1]=c*y+l*g+f*v,n[4]=c*m+l*w+f*S,n[7]=c*x+l*b+f*A,n[2]=u*y+p*g+d*v,n[5]=u*m+p*w+d*S,n[8]=u*x+p*b+d*A,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],o=t[5],a=t[6],c=t[7],l=t[8];return e*r*l-e*o*c-i*n*l+i*o*a+s*n*c-s*r*a}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],o=t[5],a=t[6],c=t[7],l=t[8],f=l*r-o*c,u=o*a-l*n,p=c*n-r*a,d=e*f+i*u+s*p;if(d===0)return this.set(0,0,0,0,0,0,0,0,0);const y=1/d;return t[0]=f*y,t[1]=(s*c-l*i)*y,t[2]=(o*i-s*r)*y,t[3]=u*y,t[4]=(l*e-s*a)*y,t[5]=(s*n-o*e)*y,t[6]=p*y,t[7]=(i*a-c*e)*y,t[8]=(r*e-i*n)*y,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,n,r,o){const a=Math.cos(n),c=Math.sin(n);return this.set(i*a,i*c,-i*(a*r+c*o)+r+t,-s*c,s*a,-s*(-c*r+a*o)+o+e,0,0,1),this}scale(t,e){return this.premultiply(yn.makeScale(t,e)),this}rotate(t){return this.premultiply(yn.makeRotation(-t)),this}translate(t,e){return this.premultiply(yn.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<9;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const yn=new Ut;function nh(h){for(let t=h.length-1;t>=0;--t)if(h[t]>=65535)return!0;return!1}const rh={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function ke(h,t){return new rh[h](t)}function xn(h){return document.createElementNS("http://www.w3.org/1999/xhtml",h)}const St={enabled:!0,workingColorSpace:to,spaces:{},convert:function(h,t,e){return this.enabled===!1||t===e||!t||!e||(this.spaces[t].transfer===pn&&(h.r=Gt(h.r),h.g=Gt(h.g),h.b=Gt(h.b)),this.spaces[t].primaries!==this.spaces[e].primaries&&(h.applyMatrix3(this.spaces[t].toXYZ),h.applyMatrix3(this.spaces[e].fromXYZ)),this.spaces[e].transfer===pn&&(h.r=Ee(h.r),h.g=Ee(h.g),h.b=Ee(h.b))),h},fromWorkingColorSpace:function(h,t){return this.convert(h,this.workingColorSpace,t)},toWorkingColorSpace:function(h,t){return this.convert(h,t,this.workingColorSpace)},getPrimaries:function(h){return this.spaces[h].primaries},getTransfer:function(h){return h===jr?eo:this.spaces[h].transfer},getLuminanceCoefficients:function(h,t=this.workingColorSpace){return h.fromArray(this.spaces[t].luminanceCoefficients)},define:function(h){Object.assign(this.spaces,h)},_getMatrix:function(h,t,e){return h.copy(this.spaces[t].toXYZ).multiply(this.spaces[e].fromXYZ)},_getDrawingBufferColorSpace:function(h){return this.spaces[h].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(h=this.workingColorSpace){return this.spaces[h].workingColorSpaceConfig.unpackColorSpace}};function Gt(h){return h<.04045?h*.0773993808:Math.pow(h*.9478672986+.0521327014,2.4)}function Ee(h){return h<.0031308?h*12.92:1.055*Math.pow(h,.41666)-.055}const io=[.64,.33,.3,.6,.15,.06],so=[.2126,.7152,.0722],no=[.3127,.329],ro=new Ut().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),oo=new Ut().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);St.define({[to]:{primaries:io,whitePoint:no,transfer:eo,toXYZ:ro,fromXYZ:oo,luminanceCoefficients:so,workingColorSpaceConfig:{unpackColorSpace:Ft},outputColorSpaceConfig:{drawingBufferColorSpace:Ft}},[Ft]:{primaries:io,whitePoint:no,transfer:pn,toXYZ:ro,fromXYZ:oo,luminanceCoefficients:so,outputColorSpaceConfig:{drawingBufferColorSpace:Ft}}});let Re;class oh{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Re===void 0&&(Re=xn("canvas")),Re.width=t.width,Re.height=t.height;const i=Re.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=Re}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=xn("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const s=i.getImageData(0,0,t.width,t.height),n=s.data;for(let r=0;r<n.length;r++)n[r]=Gt(n[r]/255)*255;return i.putImageData(s,0,0),e}else if(t.data){const e=t.data.slice(0);for(let i=0;i<e.length;i++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[i]=Math.floor(Gt(e[i]/255)*255):e[i]=Gt(e[i]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let ah=0;class pi{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:ah++}),this.uuid=kt(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const i={uuid:this.uuid,url:""},s=this.data;if(s!==null){let n;if(Array.isArray(s)){n=[];for(let r=0,o=s.length;r<o;r++)s[r].isDataTexture?n.push(gn(s[r].image)):n.push(gn(s[r]))}else n=gn(s);i.url=n}return e||(t.images[this.uuid]=i),i}}function gn(h){return typeof HTMLImageElement<"u"&&h instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&h instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&h instanceof ImageBitmap?oh.getDataURL(h):h.data?{data:Array.from(h.data),width:h.width,height:h.height,type:h.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let hh=0;class Wt extends $i{constructor(t=Wt.DEFAULT_IMAGE,e=Wt.DEFAULT_MAPPING,i=1001,s=1001,n=1006,r=1008,o=1023,a=1009,c=Wt.DEFAULT_ANISOTROPY,l=jr){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:hh++}),this.uuid=kt(),this.name="",this.source=new pi(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=i,this.wrapT=s,this.magFilter=n,this.minFilter=r,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=a,this.offset=new P(0,0),this.repeat=new P(1,1),this.center=new P(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ut,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=l,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==300)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}Wt.DEFAULT_IMAGE=null,Wt.DEFAULT_MAPPING=300,Wt.DEFAULT_ANISOTROPY=1;class pt{constructor(t=0,e=0,i=0,s=1){pt.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s+r[12]*n,this.y=r[1]*e+r[5]*i+r[9]*s+r[13]*n,this.z=r[2]*e+r[6]*i+r[10]*s+r[14]*n,this.w=r[3]*e+r[7]*i+r[11]*s+r[15]*n,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,n;const a=t.elements,c=a[0],l=a[4],f=a[8],u=a[1],p=a[5],d=a[9],y=a[2],m=a[6],x=a[10];if(Math.abs(l-u)<.01&&Math.abs(f-y)<.01&&Math.abs(d-m)<.01){if(Math.abs(l+u)<.1&&Math.abs(f+y)<.1&&Math.abs(d+m)<.1&&Math.abs(c+p+x-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const w=(c+1)/2,b=(p+1)/2,v=(x+1)/2,S=(l+u)/4,A=(f+y)/4,_=(d+m)/4;return w>b&&w>v?w<.01?(i=0,s=.707106781,n=.707106781):(i=Math.sqrt(w),s=S/i,n=A/i):b>v?b<.01?(i=.707106781,s=0,n=.707106781):(s=Math.sqrt(b),i=S/s,n=_/s):v<.01?(i=.707106781,s=.707106781,n=0):(n=Math.sqrt(v),i=A/n,s=_/n),this.set(i,s,n,e),this}let g=Math.sqrt((m-d)*(m-d)+(f-y)*(f-y)+(u-l)*(u-l));return Math.abs(g)<.001&&(g=1),this.x=(m-d)/g,this.y=(f-y)/g,this.z=(u-l)/g,this.w=Math.acos((c+p+x-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Le{constructor(t=0,e=0,i=0,s=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=s}static slerpFlat(t,e,i,s,n,r,o){let a=i[s+0],c=i[s+1],l=i[s+2],f=i[s+3];const u=n[r+0],p=n[r+1],d=n[r+2],y=n[r+3];if(o===0){t[e+0]=a,t[e+1]=c,t[e+2]=l,t[e+3]=f;return}if(o===1){t[e+0]=u,t[e+1]=p,t[e+2]=d,t[e+3]=y;return}if(f!==y||a!==u||c!==p||l!==d){let m=1-o;const x=a*u+c*p+l*d+f*y,g=x>=0?1:-1,w=1-x*x;if(w>Number.EPSILON){const v=Math.sqrt(w),S=Math.atan2(v,x*g);m=Math.sin(m*S)/v,o=Math.sin(o*S)/v}const b=o*g;if(a=a*m+u*b,c=c*m+p*b,l=l*m+d*b,f=f*m+y*b,m===1-o){const v=1/Math.sqrt(a*a+c*c+l*l+f*f);a*=v,c*=v,l*=v,f*=v}}t[e]=a,t[e+1]=c,t[e+2]=l,t[e+3]=f}static multiplyQuaternionsFlat(t,e,i,s,n,r){const o=i[s],a=i[s+1],c=i[s+2],l=i[s+3],f=n[r],u=n[r+1],p=n[r+2],d=n[r+3];return t[e]=o*d+l*f+a*p-c*u,t[e+1]=a*d+l*u+c*f-o*p,t[e+2]=c*d+l*p+o*u-a*f,t[e+3]=l*d-o*f-a*u-c*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,s=t._y,n=t._z,r=t._order,o=Math.cos,a=Math.sin,c=o(i/2),l=o(s/2),f=o(n/2),u=a(i/2),p=a(s/2),d=a(n/2);switch(r){case"XYZ":this._x=u*l*f+c*p*d,this._y=c*p*f-u*l*d,this._z=c*l*d+u*p*f,this._w=c*l*f-u*p*d;break;case"YXZ":this._x=u*l*f+c*p*d,this._y=c*p*f-u*l*d,this._z=c*l*d-u*p*f,this._w=c*l*f+u*p*d;break;case"ZXY":this._x=u*l*f-c*p*d,this._y=c*p*f+u*l*d,this._z=c*l*d+u*p*f,this._w=c*l*f-u*p*d;break;case"ZYX":this._x=u*l*f-c*p*d,this._y=c*p*f+u*l*d,this._z=c*l*d-u*p*f,this._w=c*l*f+u*p*d;break;case"YZX":this._x=u*l*f+c*p*d,this._y=c*p*f+u*l*d,this._z=c*l*d-u*p*f,this._w=c*l*f-u*p*d;break;case"XZY":this._x=u*l*f-c*p*d,this._y=c*p*f-u*l*d,this._z=c*l*d+u*p*f,this._w=c*l*f+u*p*d;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],n=e[8],r=e[1],o=e[5],a=e[9],c=e[2],l=e[6],f=e[10],u=i+o+f;if(u>0){const p=.5/Math.sqrt(u+1);this._w=.25/p,this._x=(l-a)*p,this._y=(n-c)*p,this._z=(r-s)*p}else if(i>o&&i>f){const p=2*Math.sqrt(1+i-o-f);this._w=(l-a)/p,this._x=.25*p,this._y=(s+r)/p,this._z=(n+c)/p}else if(o>f){const p=2*Math.sqrt(1+o-i-f);this._w=(n-c)/p,this._x=(s+r)/p,this._y=.25*p,this._z=(a+l)/p}else{const p=2*Math.sqrt(1+f-i-o);this._w=(r-s)/p,this._x=(n+c)/p,this._y=(a+l)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(rt(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,n=t._z,r=t._w,o=e._x,a=e._y,c=e._z,l=e._w;return this._x=i*l+r*o+s*c-n*a,this._y=s*l+r*a+n*o-i*c,this._z=n*l+r*c+i*a-s*o,this._w=r*l-i*o-s*a-n*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,s=this._y,n=this._z,r=this._w;let o=r*t._w+i*t._x+s*t._y+n*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=r,this._x=i,this._y=s,this._z=n,this;const a=1-o*o;if(a<=Number.EPSILON){const p=1-e;return this._w=p*r+e*this._w,this._x=p*i+e*this._x,this._y=p*s+e*this._y,this._z=p*n+e*this._z,this.normalize(),this}const c=Math.sqrt(a),l=Math.atan2(c,o),f=Math.sin((1-e)*l)/c,u=Math.sin(e*l)/c;return this._w=r*f+this._w*u,this._x=i*f+this._x*u,this._y=s*f+this._y*u,this._z=n*f+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),s=Math.sqrt(1-i),n=Math.sqrt(i);return this.set(s*Math.sin(t),s*Math.cos(t),n*Math.sin(e),n*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class M{constructor(t=0,e=0,i=0){M.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(ao.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(ao.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*s,this.y=n[1]*e+n[4]*i+n[7]*s,this.z=n[2]*e+n[5]*i+n[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=t.elements,r=1/(n[3]*e+n[7]*i+n[11]*s+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*s+n[12])*r,this.y=(n[1]*e+n[5]*i+n[9]*s+n[13])*r,this.z=(n[2]*e+n[6]*i+n[10]*s+n[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,n=t.x,r=t.y,o=t.z,a=t.w,c=2*(r*s-o*i),l=2*(o*e-n*s),f=2*(n*i-r*e);return this.x=e+a*c+r*f-o*l,this.y=i+a*l+o*c-n*f,this.z=s+a*f+n*l-r*c,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*s,this.y=n[1]*e+n[5]*i+n[9]*s,this.z=n[2]*e+n[6]*i+n[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,n=t.z,r=e.x,o=e.y,a=e.z;return this.x=s*a-n*o,this.y=n*r-i*a,this.z=i*o-s*r,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return wn.copy(this).projectOnVector(t),this.sub(wn)}reflect(t){return this.sub(wn.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(rt(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const wn=new M,ao=new Le;class Y{constructor(t=new M(1/0,1/0,1/0),e=new M(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e+=3)this.expandByPoint(Et.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,i=t.count;e<i;e++)this.expandByPoint(Et.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=Et.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(i!==void 0){const n=i.getAttribute("position");if(e===!0&&n!==void 0&&t.isInstancedMesh!==!0)for(let r=0,o=n.count;r<o;r++)t.isMesh===!0?t.getVertexPosition(r,Et):Et.fromBufferAttribute(n,r),Et.applyMatrix4(t.matrixWorld),this.expandByPoint(Et);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Zi.copy(t.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),Zi.copy(i.boundingBox)),Zi.applyMatrix4(t.matrixWorld),this.union(Zi)}const s=t.children;for(let n=0,r=s.length;n<r;n++)this.expandByObject(s[n],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,Et),Et.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(di),Yi.subVectors(this.max,di),Oe.subVectors(t.a,di),Ne.subVectors(t.b,di),De.subVectors(t.c,di),ae.subVectors(Ne,Oe),he.subVectors(De,Ne),be.subVectors(Oe,De);let e=[0,-ae.z,ae.y,0,-he.z,he.y,0,-be.z,be.y,ae.z,0,-ae.x,he.z,0,-he.x,be.z,0,-be.x,-ae.y,ae.x,0,-he.y,he.x,0,-be.y,be.x,0];return!bn(e,Oe,Ne,De,Yi)||(e=[1,0,0,0,1,0,0,0,1],!bn(e,Oe,Ne,De,Yi))?!1:(Qi.crossVectors(ae,he),e=[Qi.x,Qi.y,Qi.z],bn(e,Oe,Ne,De,Yi))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,Et).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(Et).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:($t[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),$t[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),$t[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),$t[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),$t[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),$t[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),$t[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),$t[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints($t),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const $t=[new M,new M,new M,new M,new M,new M,new M,new M],Et=new M,Zi=new Y,Oe=new M,Ne=new M,De=new M,ae=new M,he=new M,be=new M,di=new M,Yi=new M,Qi=new M,Me=new M;function bn(h,t,e,i,s){for(let n=0,r=h.length-3;n<=r;n+=3){Me.fromArray(h,n);const o=s.x*Math.abs(Me.x)+s.y*Math.abs(Me.y)+s.z*Math.abs(Me.z),a=t.dot(Me),c=e.dot(Me),l=i.dot(Me);if(Math.max(-Math.max(a,c,l),Math.min(a,c,l))>o)return!1}return!0}const ch=new Y,mi=new M,Mn=new M;class ht{constructor(t=new M,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):ch.setFromPoints(t).getCenter(i);let s=0;for(let n=0,r=t.length;n<r;n++)s=Math.max(s,i.distanceToSquared(t[n]));return this.radius=Math.sqrt(s),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;mi.subVectors(t,this.center);const e=mi.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),s=(i-this.radius)*.5;this.center.addScaledVector(mi,s/i),this.radius+=s}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(Mn.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(mi.copy(t.center).add(Mn)),this.expandByPoint(mi.copy(t.center).sub(Mn))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Xt=new M,vn=new M,Ki=new M,ce=new M,Sn=new M,ji=new M,An=new M;class Ve{constructor(t=new M,e=new M(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Xt)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Xt.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Xt.copy(this.origin).addScaledVector(this.direction,e),Xt.distanceToSquared(t))}distanceSqToSegment(t,e,i,s){vn.copy(t).add(e).multiplyScalar(.5),Ki.copy(e).sub(t).normalize(),ce.copy(this.origin).sub(vn);const n=t.distanceTo(e)*.5,r=-this.direction.dot(Ki),o=ce.dot(this.direction),a=-ce.dot(Ki),c=ce.lengthSq(),l=Math.abs(1-r*r);let f,u,p,d;if(l>0)if(f=r*a-o,u=r*o-a,d=n*l,f>=0)if(u>=-d)if(u<=d){const y=1/l;f*=y,u*=y,p=f*(f+r*u+2*o)+u*(r*f+u+2*a)+c}else u=n,f=Math.max(0,-(r*u+o)),p=-f*f+u*(u+2*a)+c;else u=-n,f=Math.max(0,-(r*u+o)),p=-f*f+u*(u+2*a)+c;else u<=-d?(f=Math.max(0,-(-r*n+o)),u=f>0?-n:Math.min(Math.max(-n,-a),n),p=-f*f+u*(u+2*a)+c):u<=d?(f=0,u=Math.min(Math.max(-n,-a),n),p=u*(u+2*a)+c):(f=Math.max(0,-(r*n+o)),u=f>0?n:Math.min(Math.max(-n,-a),n),p=-f*f+u*(u+2*a)+c);else u=r>0?-n:n,f=Math.max(0,-(r*u+o)),p=-f*f+u*(u+2*a)+c;return i&&i.copy(this.origin).addScaledVector(this.direction,f),s&&s.copy(vn).addScaledVector(Ki,u),p}intersectSphere(t,e){Xt.subVectors(t.center,this.origin);const i=Xt.dot(this.direction),s=Xt.dot(Xt)-i*i,n=t.radius*t.radius;if(s>n)return null;const r=Math.sqrt(n-s),o=i-r,a=i+r;return a<0?null:o<0?this.at(a,e):this.at(o,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,s,n,r,o,a;const c=1/this.direction.x,l=1/this.direction.y,f=1/this.direction.z,u=this.origin;return c>=0?(i=(t.min.x-u.x)*c,s=(t.max.x-u.x)*c):(i=(t.max.x-u.x)*c,s=(t.min.x-u.x)*c),l>=0?(n=(t.min.y-u.y)*l,r=(t.max.y-u.y)*l):(n=(t.max.y-u.y)*l,r=(t.min.y-u.y)*l),i>r||n>s||((n>i||isNaN(i))&&(i=n),(r<s||isNaN(s))&&(s=r),f>=0?(o=(t.min.z-u.z)*f,a=(t.max.z-u.z)*f):(o=(t.max.z-u.z)*f,a=(t.min.z-u.z)*f),i>a||o>s)||((o>i||i!==i)&&(i=o),(a<s||s!==s)&&(s=a),s<0)?null:this.at(i>=0?i:s,e)}intersectsBox(t){return this.intersectBox(t,Xt)!==null}intersectTriangle(t,e,i,s,n){Sn.subVectors(e,t),ji.subVectors(i,t),An.crossVectors(Sn,ji);let r=this.direction.dot(An),o;if(r>0){if(s)return null;o=1}else if(r<0)o=-1,r=-r;else return null;ce.subVectors(this.origin,t);const a=o*this.direction.dot(ji.crossVectors(ce,ji));if(a<0)return null;const c=o*this.direction.dot(Sn.cross(ce));if(c<0||a+c>r)return null;const l=-o*ce.dot(An);return l<0?null:this.at(l/r,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class N{constructor(t,e,i,s,n,r,o,a,c,l,f,u,p,d,y,m){N.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,i,s,n,r,o,a,c,l,f,u,p,d,y,m)}set(t,e,i,s,n,r,o,a,c,l,f,u,p,d,y,m){const x=this.elements;return x[0]=t,x[4]=e,x[8]=i,x[12]=s,x[1]=n,x[5]=r,x[9]=o,x[13]=a,x[2]=c,x[6]=l,x[10]=f,x[14]=u,x[3]=p,x[7]=d,x[11]=y,x[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new N().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/Ue.setFromMatrixColumn(t,0).length(),n=1/Ue.setFromMatrixColumn(t,1).length(),r=1/Ue.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,s=t.y,n=t.z,r=Math.cos(i),o=Math.sin(i),a=Math.cos(s),c=Math.sin(s),l=Math.cos(n),f=Math.sin(n);if(t.order==="XYZ"){const u=r*l,p=r*f,d=o*l,y=o*f;e[0]=a*l,e[4]=-a*f,e[8]=c,e[1]=p+d*c,e[5]=u-y*c,e[9]=-o*a,e[2]=y-u*c,e[6]=d+p*c,e[10]=r*a}else if(t.order==="YXZ"){const u=a*l,p=a*f,d=c*l,y=c*f;e[0]=u+y*o,e[4]=d*o-p,e[8]=r*c,e[1]=r*f,e[5]=r*l,e[9]=-o,e[2]=p*o-d,e[6]=y+u*o,e[10]=r*a}else if(t.order==="ZXY"){const u=a*l,p=a*f,d=c*l,y=c*f;e[0]=u-y*o,e[4]=-r*f,e[8]=d+p*o,e[1]=p+d*o,e[5]=r*l,e[9]=y-u*o,e[2]=-r*c,e[6]=o,e[10]=r*a}else if(t.order==="ZYX"){const u=r*l,p=r*f,d=o*l,y=o*f;e[0]=a*l,e[4]=d*c-p,e[8]=u*c+y,e[1]=a*f,e[5]=y*c+u,e[9]=p*c-d,e[2]=-c,e[6]=o*a,e[10]=r*a}else if(t.order==="YZX"){const u=r*a,p=r*c,d=o*a,y=o*c;e[0]=a*l,e[4]=y-u*f,e[8]=d*f+p,e[1]=f,e[5]=r*l,e[9]=-o*l,e[2]=-c*l,e[6]=p*f+d,e[10]=u-y*f}else if(t.order==="XZY"){const u=r*a,p=r*c,d=o*a,y=o*c;e[0]=a*l,e[4]=-f,e[8]=c*l,e[1]=u*f+y,e[5]=r*l,e[9]=p*f-d,e[2]=d*f-p,e[6]=o*l,e[10]=y*f+u}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(lh,t,uh)}lookAt(t,e,i){const s=this.elements;return At.subVectors(t,e),At.lengthSq()===0&&(At.z=1),At.normalize(),le.crossVectors(i,At),le.lengthSq()===0&&(Math.abs(i.z)===1?At.x+=1e-4:At.z+=1e-4,At.normalize(),le.crossVectors(i,At)),le.normalize(),ts.crossVectors(At,le),s[0]=le.x,s[4]=ts.x,s[8]=At.x,s[1]=le.y,s[5]=ts.y,s[9]=At.y,s[2]=le.z,s[6]=ts.z,s[10]=At.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],o=i[4],a=i[8],c=i[12],l=i[1],f=i[5],u=i[9],p=i[13],d=i[2],y=i[6],m=i[10],x=i[14],g=i[3],w=i[7],b=i[11],v=i[15],S=s[0],A=s[4],_=s[8],z=s[12],T=s[1],I=s[5],C=s[9],B=s[13],F=s[2],O=s[6],D=s[10],et=s[14],lt=s[3],G=s[7],nt=s[11],j=s[15];return n[0]=r*S+o*T+a*F+c*lt,n[4]=r*A+o*I+a*O+c*G,n[8]=r*_+o*C+a*D+c*nt,n[12]=r*z+o*B+a*et+c*j,n[1]=l*S+f*T+u*F+p*lt,n[5]=l*A+f*I+u*O+p*G,n[9]=l*_+f*C+u*D+p*nt,n[13]=l*z+f*B+u*et+p*j,n[2]=d*S+y*T+m*F+x*lt,n[6]=d*A+y*I+m*O+x*G,n[10]=d*_+y*C+m*D+x*nt,n[14]=d*z+y*B+m*et+x*j,n[3]=g*S+w*T+b*F+v*lt,n[7]=g*A+w*I+b*O+v*G,n[11]=g*_+w*C+b*D+v*nt,n[15]=g*z+w*B+b*et+v*j,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],n=t[12],r=t[1],o=t[5],a=t[9],c=t[13],l=t[2],f=t[6],u=t[10],p=t[14],d=t[3],y=t[7],m=t[11],x=t[15];return d*(+n*a*f-s*c*f-n*o*u+i*c*u+s*o*p-i*a*p)+y*(+e*a*p-e*c*u+n*r*u-s*r*p+s*c*l-n*a*l)+m*(+e*c*f-e*o*p-n*r*f+i*r*p+n*o*l-i*c*l)+x*(-s*o*l-e*a*f+e*o*u+s*r*f-i*r*u+i*a*l)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],o=t[5],a=t[6],c=t[7],l=t[8],f=t[9],u=t[10],p=t[11],d=t[12],y=t[13],m=t[14],x=t[15],g=f*m*c-y*u*c+y*a*p-o*m*p-f*a*x+o*u*x,w=d*u*c-l*m*c-d*a*p+r*m*p+l*a*x-r*u*x,b=l*y*c-d*f*c+d*o*p-r*y*p-l*o*x+r*f*x,v=d*f*a-l*y*a-d*o*u+r*y*u+l*o*m-r*f*m,S=e*g+i*w+s*b+n*v;if(S===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const A=1/S;return t[0]=g*A,t[1]=(y*u*n-f*m*n-y*s*p+i*m*p+f*s*x-i*u*x)*A,t[2]=(o*m*n-y*a*n+y*s*c-i*m*c-o*s*x+i*a*x)*A,t[3]=(f*a*n-o*u*n-f*s*c+i*u*c+o*s*p-i*a*p)*A,t[4]=w*A,t[5]=(l*m*n-d*u*n+d*s*p-e*m*p-l*s*x+e*u*x)*A,t[6]=(d*a*n-r*m*n-d*s*c+e*m*c+r*s*x-e*a*x)*A,t[7]=(r*u*n-l*a*n+l*s*c-e*u*c-r*s*p+e*a*p)*A,t[8]=b*A,t[9]=(d*f*n-l*y*n-d*i*p+e*y*p+l*i*x-e*f*x)*A,t[10]=(r*y*n-d*o*n+d*i*c-e*y*c-r*i*x+e*o*x)*A,t[11]=(l*o*n-r*f*n-l*i*c+e*f*c+r*i*p-e*o*p)*A,t[12]=v*A,t[13]=(l*y*s-d*f*s+d*i*u-e*y*u-l*i*m+e*f*m)*A,t[14]=(d*o*s-r*y*s-d*i*a+e*y*a+r*i*m-e*o*m)*A,t[15]=(r*f*s-l*o*s+l*i*a-e*f*a-r*i*u+e*o*u)*A,this}scale(t){const e=this.elements,i=t.x,s=t.y,n=t.z;return e[0]*=i,e[4]*=s,e[8]*=n,e[1]*=i,e[5]*=s,e[9]*=n,e[2]*=i,e[6]*=s,e[10]*=n,e[3]*=i,e[7]*=s,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),n=1-i,r=t.x,o=t.y,a=t.z,c=n*r,l=n*o;return this.set(c*r+i,c*o-s*a,c*a+s*o,0,c*o+s*a,l*o+i,l*a-s*r,0,c*a-s*o,l*a+s*r,n*a*a+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,n,r){return this.set(1,i,n,0,t,1,r,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,n=e._x,r=e._y,o=e._z,a=e._w,c=n+n,l=r+r,f=o+o,u=n*c,p=n*l,d=n*f,y=r*l,m=r*f,x=o*f,g=a*c,w=a*l,b=a*f,v=i.x,S=i.y,A=i.z;return s[0]=(1-(y+x))*v,s[1]=(p+b)*v,s[2]=(d-w)*v,s[3]=0,s[4]=(p-b)*S,s[5]=(1-(u+x))*S,s[6]=(m+g)*S,s[7]=0,s[8]=(d+w)*A,s[9]=(m-g)*A,s[10]=(1-(u+y))*A,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let n=Ue.set(s[0],s[1],s[2]).length();const r=Ue.set(s[4],s[5],s[6]).length(),o=Ue.set(s[8],s[9],s[10]).length();this.determinant()<0&&(n=-n),t.x=s[12],t.y=s[13],t.z=s[14],Rt.copy(this);const c=1/n,l=1/r,f=1/o;return Rt.elements[0]*=c,Rt.elements[1]*=c,Rt.elements[2]*=c,Rt.elements[4]*=l,Rt.elements[5]*=l,Rt.elements[6]*=l,Rt.elements[8]*=f,Rt.elements[9]*=f,Rt.elements[10]*=f,e.setFromRotationMatrix(Rt),i.x=n,i.y=r,i.z=o,this}makePerspective(t,e,i,s,n,r,o=2e3){const a=this.elements,c=2*n/(e-t),l=2*n/(i-s),f=(e+t)/(e-t),u=(i+s)/(i-s);let p,d;if(o===2e3)p=-(r+n)/(r-n),d=-2*r*n/(r-n);else if(o===2001)p=-r/(r-n),d=-r*n/(r-n);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return a[0]=c,a[4]=0,a[8]=f,a[12]=0,a[1]=0,a[5]=l,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=p,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,i,s,n,r,o=2e3){const a=this.elements,c=1/(e-t),l=1/(i-s),f=1/(r-n),u=(e+t)*c,p=(i+s)*l;let d,y;if(o===2e3)d=(r+n)*f,y=-2*f;else if(o===2001)d=n*f,y=-1*f;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return a[0]=2*c,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-p,a[2]=0,a[6]=0,a[10]=y,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const Ue=new M,Rt=new N,lh=new M(0,0,0),uh=new M(1,1,1),le=new M,ts=new M,At=new M,ho=new N,co=new Le;class qt{constructor(t=0,e=0,i=0,s=qt.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,n=s[0],r=s[4],o=s[8],a=s[1],c=s[5],l=s[9],f=s[2],u=s[6],p=s[10];switch(e){case"XYZ":this._y=Math.asin(rt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-l,p),this._z=Math.atan2(-r,n)):(this._x=Math.atan2(u,c),this._z=0);break;case"YXZ":this._x=Math.asin(-rt(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(a,c)):(this._y=Math.atan2(-f,n),this._z=0);break;case"ZXY":this._x=Math.asin(rt(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-f,p),this._z=Math.atan2(-r,c)):(this._y=0,this._z=Math.atan2(a,n));break;case"ZYX":this._y=Math.asin(-rt(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(u,p),this._z=Math.atan2(a,n)):(this._x=0,this._z=Math.atan2(-r,c));break;case"YZX":this._z=Math.asin(rt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-l,c),this._y=Math.atan2(-f,n)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-rt(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(u,c),this._y=Math.atan2(o,n)):(this._x=Math.atan2(-l,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return ho.makeRotationFromQuaternion(t),this.setFromRotationMatrix(ho,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return co.setFromEuler(this),this.setFromQuaternion(co,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}qt.DEFAULT_ORDER="XYZ";class lo{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let fh=0;const uo=new M,We=new Le,Zt=new N,es=new M,yi=new M,ph=new M,dh=new Le,fo=new M(1,0,0),po=new M(0,1,0),mo=new M(0,0,1),yo={type:"added"},mh={type:"removed"},qe={type:"childadded",child:null},_n={type:"childremoved",child:null};class X extends $i{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:fh++}),this.uuid=kt(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=X.DEFAULT_UP.clone();const t=new M,e=new qt,i=new Le,s=new M(1,1,1);function n(){i.setFromEuler(e,!1)}function r(){e.setFromQuaternion(i,void 0,!1)}e._onChange(n),i._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new N},normalMatrix:{value:new Ut}}),this.matrix=new N,this.matrixWorld=new N,this.matrixAutoUpdate=X.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=X.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new lo,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return We.setFromAxisAngle(t,e),this.quaternion.multiply(We),this}rotateOnWorldAxis(t,e){return We.setFromAxisAngle(t,e),this.quaternion.premultiply(We),this}rotateX(t){return this.rotateOnAxis(fo,t)}rotateY(t){return this.rotateOnAxis(po,t)}rotateZ(t){return this.rotateOnAxis(mo,t)}translateOnAxis(t,e){return uo.copy(t).applyQuaternion(this.quaternion),this.position.add(uo.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(fo,t)}translateY(t){return this.translateOnAxis(po,t)}translateZ(t){return this.translateOnAxis(mo,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Zt.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?es.copy(t):es.set(t,e,i);const s=this.parent;this.updateWorldMatrix(!0,!1),yi.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Zt.lookAt(yi,es,this.up):Zt.lookAt(es,yi,this.up),this.quaternion.setFromRotationMatrix(Zt),s&&(Zt.extractRotation(s.matrixWorld),We.setFromRotationMatrix(Zt),this.quaternion.premultiply(We.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(yo),qe.child=t,this.dispatchEvent(qe),qe.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(mh),_n.child=t,this.dispatchEvent(_n),_n.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Zt.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Zt.multiply(t.parent.matrixWorld)),t.applyMatrix4(Zt),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(yo),qe.child=t,this.dispatchEvent(qe),qe.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,s=this.children.length;i<s;i++){const r=this.children[i].getObjectByProperty(t,e);if(r!==void 0)return r}}getObjectsByProperty(t,e,i=[]){this[t]===e&&i.push(this);const s=this.children;for(let n=0,r=s.length;n<r;n++)s[n].getObjectsByProperty(t,e,i);return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(yi,t,ph),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(yi,dh,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const s=this.children;for(let n=0,r=s.length;n<r;n++)s[n].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),s.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(s.type="BatchedMesh",s.perObjectFrustumCulled=this.perObjectFrustumCulled,s.sortObjects=this.sortObjects,s.drawRanges=this._drawRanges,s.reservedRanges=this._reservedRanges,s.visibility=this._visibility,s.active=this._active,s.bounds=this._bounds.map(o=>({boxInitialized:o.boxInitialized,boxMin:o.box.min.toArray(),boxMax:o.box.max.toArray(),sphereInitialized:o.sphereInitialized,sphereRadius:o.sphere.radius,sphereCenter:o.sphere.center.toArray()})),s.maxInstanceCount=this._maxInstanceCount,s.maxVertexCount=this._maxVertexCount,s.maxIndexCount=this._maxIndexCount,s.geometryInitialized=this._geometryInitialized,s.geometryCount=this._geometryCount,s.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(s.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(s.boundingSphere={center:s.boundingSphere.center.toArray(),radius:s.boundingSphere.radius}),this.boundingBox!==null&&(s.boundingBox={min:s.boundingBox.min.toArray(),max:s.boundingBox.max.toArray()}));function n(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(t)),a.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=n(t.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let c=0,l=a.length;c<l;c++){const f=a[c];n(t.shapes,f)}else n(t.shapes,a)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(n(t.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,c=this.material.length;a<c;a++)o.push(n(t.materials,this.material[a]));s.material=o}else s.material=n(t.materials,this.material);if(this.children.length>0){s.children=[];for(let o=0;o<this.children.length;o++)s.children.push(this.children[o].toJSON(t).object)}if(this.animations.length>0){s.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];s.animations.push(n(t.animations,a))}}if(e){const o=r(t.geometries),a=r(t.materials),c=r(t.textures),l=r(t.images),f=r(t.shapes),u=r(t.skeletons),p=r(t.animations),d=r(t.nodes);o.length>0&&(i.geometries=o),a.length>0&&(i.materials=a),c.length>0&&(i.textures=c),l.length>0&&(i.images=l),f.length>0&&(i.shapes=f),u.length>0&&(i.skeletons=u),p.length>0&&(i.animations=p),d.length>0&&(i.nodes=d)}return i.object=s,i;function r(o){const a=[];for(const c in o){const l=o[c];delete l.metadata,a.push(l)}return a}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const s=t.children[i];this.add(s.clone())}return this}}X.DEFAULT_UP=new M(0,1,0),X.DEFAULT_MATRIX_AUTO_UPDATE=!0,X.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Lt=new M,Yt=new M,zn=new M,Qt=new M,He=new M,Je=new M,xo=new M,Tn=new M,Cn=new M,In=new M,Bn=new pt,Pn=new pt,Fn=new pt;class ot{constructor(t=new M,e=new M,i=new M){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,s){s.subVectors(i,e),Lt.subVectors(t,e),s.cross(Lt);const n=s.lengthSq();return n>0?s.multiplyScalar(1/Math.sqrt(n)):s.set(0,0,0)}static getBarycoord(t,e,i,s,n){Lt.subVectors(s,e),Yt.subVectors(i,e),zn.subVectors(t,e);const r=Lt.dot(Lt),o=Lt.dot(Yt),a=Lt.dot(zn),c=Yt.dot(Yt),l=Yt.dot(zn),f=r*c-o*o;if(f===0)return n.set(0,0,0),null;const u=1/f,p=(c*a-o*l)*u,d=(r*l-o*a)*u;return n.set(1-p-d,d,p)}static containsPoint(t,e,i,s){return this.getBarycoord(t,e,i,s,Qt)===null?!1:Qt.x>=0&&Qt.y>=0&&Qt.x+Qt.y<=1}static getInterpolation(t,e,i,s,n,r,o,a){return this.getBarycoord(t,e,i,s,Qt)===null?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(n,Qt.x),a.addScaledVector(r,Qt.y),a.addScaledVector(o,Qt.z),a)}static getInterpolatedAttribute(t,e,i,s,n,r){return Bn.setScalar(0),Pn.setScalar(0),Fn.setScalar(0),Bn.fromBufferAttribute(t,e),Pn.fromBufferAttribute(t,i),Fn.fromBufferAttribute(t,s),r.setScalar(0),r.addScaledVector(Bn,n.x),r.addScaledVector(Pn,n.y),r.addScaledVector(Fn,n.z),r}static isFrontFacing(t,e,i,s){return Lt.subVectors(i,e),Yt.subVectors(t,e),Lt.cross(Yt).dot(s)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,s){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,i,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Lt.subVectors(this.c,this.b),Yt.subVectors(this.a,this.b),Lt.cross(Yt).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ot.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ot.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,i,s,n){return ot.getInterpolation(t,this.a,this.b,this.c,e,i,s,n)}containsPoint(t){return ot.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ot.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,s=this.b,n=this.c;let r,o;He.subVectors(s,i),Je.subVectors(n,i),Tn.subVectors(t,i);const a=He.dot(Tn),c=Je.dot(Tn);if(a<=0&&c<=0)return e.copy(i);Cn.subVectors(t,s);const l=He.dot(Cn),f=Je.dot(Cn);if(l>=0&&f<=l)return e.copy(s);const u=a*f-l*c;if(u<=0&&a>=0&&l<=0)return r=a/(a-l),e.copy(i).addScaledVector(He,r);In.subVectors(t,n);const p=He.dot(In),d=Je.dot(In);if(d>=0&&p<=d)return e.copy(n);const y=p*c-a*d;if(y<=0&&c>=0&&d<=0)return o=c/(c-d),e.copy(i).addScaledVector(Je,o);const m=l*d-p*f;if(m<=0&&f-l>=0&&p-d>=0)return xo.subVectors(n,s),o=(f-l)/(f-l+(p-d)),e.copy(s).addScaledVector(xo,o);const x=1/(m+y+u);return r=y*x,o=u*x,e.copy(i).addScaledVector(He,r).addScaledVector(Je,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const go={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ue={h:0,s:0,l:0},is={h:0,s:0,l:0};function kn(h,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?h+(t-h)*6*e:e<1/2?t:e<2/3?h+(t-h)*6*(2/3-e):h}class q{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,i)}set(t,e,i){if(e===void 0&&i===void 0){const s=t;s&&s.isColor?this.copy(s):typeof s=="number"?this.setHex(s):typeof s=="string"&&this.setStyle(s)}else this.setRGB(t,e,i);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Ft){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,St.toWorkingColorSpace(this,e),this}setRGB(t,e,i,s=St.workingColorSpace){return this.r=t,this.g=e,this.b=i,St.toWorkingColorSpace(this,s),this}setHSL(t,e,i,s=St.workingColorSpace){if(t=sh(t,1),e=rt(e,0,1),i=rt(i,0,1),e===0)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+e):i+e-i*e,r=2*i-n;this.r=kn(r,n,t+1/3),this.g=kn(r,n,t),this.b=kn(r,n,t-1/3)}return St.toWorkingColorSpace(this,s),this}setStyle(t,e=Ft){function i(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let s;if(s=/^(\w+)\(([^\)]*)\)/.exec(t)){let n;const r=s[1],o=s[2];switch(r){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return i(n[4]),this.setRGB(Math.min(255,parseInt(n[1],10))/255,Math.min(255,parseInt(n[2],10))/255,Math.min(255,parseInt(n[3],10))/255,e);if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return i(n[4]),this.setRGB(Math.min(100,parseInt(n[1],10))/100,Math.min(100,parseInt(n[2],10))/100,Math.min(100,parseInt(n[3],10))/100,e);break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return i(n[4]),this.setHSL(parseFloat(n[1])/360,parseFloat(n[2])/100,parseFloat(n[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=s[1],r=n.length;if(r===3)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(r===6)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Ft){const i=go[t.toLowerCase()];return i!==void 0?this.setHex(i,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Gt(t.r),this.g=Gt(t.g),this.b=Gt(t.b),this}copyLinearToSRGB(t){return this.r=Ee(t.r),this.g=Ee(t.g),this.b=Ee(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Ft){return St.fromWorkingColorSpace(dt.copy(this),t),Math.round(rt(dt.r*255,0,255))*65536+Math.round(rt(dt.g*255,0,255))*256+Math.round(rt(dt.b*255,0,255))}getHexString(t=Ft){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=St.workingColorSpace){St.fromWorkingColorSpace(dt.copy(this),e);const i=dt.r,s=dt.g,n=dt.b,r=Math.max(i,s,n),o=Math.min(i,s,n);let a,c;const l=(o+r)/2;if(o===r)a=0,c=0;else{const f=r-o;switch(c=l<=.5?f/(r+o):f/(2-r-o),r){case i:a=(s-n)/f+(s<n?6:0);break;case s:a=(n-i)/f+2;break;case n:a=(i-s)/f+4;break}a/=6}return t.h=a,t.s=c,t.l=l,t}getRGB(t,e=St.workingColorSpace){return St.fromWorkingColorSpace(dt.copy(this),e),t.r=dt.r,t.g=dt.g,t.b=dt.b,t}getStyle(t=Ft){St.fromWorkingColorSpace(dt.copy(this),t);const e=dt.r,i=dt.g,s=dt.b;return t!==Ft?`color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(i*255)},${Math.round(s*255)})`}offsetHSL(t,e,i){return this.getHSL(ue),this.setHSL(ue.h+t,ue.s+e,ue.l+i)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(ue),t.getHSL(is);const i=mn(ue.h,is.h,e),s=mn(ue.s,is.s,e),n=mn(ue.l,is.l,e);return this.setHSL(i,s,n),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,i=this.g,s=this.b,n=t.elements;return this.r=n[0]*e+n[3]*i+n[6]*s,this.g=n[1]*e+n[4]*i+n[7]*s,this.b=n[2]*e+n[5]*i+n[8]*s,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const dt=new q;q.NAMES=go;let yh=0;class yt extends $i{static get type(){return"Material"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:yh++}),this.uuid=kt(),this.name="",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new q(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const s=this[e];if(s===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[e]=i}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(i.dispersion=this.dispersion),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapRotation!==void 0&&(i.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(i.blending=this.blending),this.side!==0&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==204&&(i.blendSrc=this.blendSrc),this.blendDst!==205&&(i.blendDst=this.blendDst),this.blendEquation!==100&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==3&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==519&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==7680&&(i.stencilFail=this.stencilFail),this.stencilZFail!==7680&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==7680&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function s(n){const r=[];for(const o in n){const a=n[o];delete a.metadata,r.push(a)}return r}if(e){const n=s(t.textures),r=s(t.images);n.length>0&&(i.textures=n),r.length>0&&(i.images=r)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const s=e.length;i=new Array(s);for(let n=0;n!==s;++n)i[n]=e[n].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class wo extends yt{static get type(){return"MeshBasicMaterial"}constructor(t){super(),this.isMeshBasicMaterial=!0,this.color=new q(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new qt,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const it=new M,ss=new P;class xt{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i,this.usage=35044,this.updateRanges=[],this.gpuType=1015,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let s=0,n=this.itemSize;s<n;s++)this.array[t+s]=e.array[i+s];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)ss.fromBufferAttribute(this,e),ss.applyMatrix3(t),this.setXY(e,ss.x,ss.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)it.fromBufferAttribute(this,e),it.applyMatrix3(t),this.setXYZ(e,it.x,it.y,it.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)it.fromBufferAttribute(this,e),it.applyMatrix4(t),this.setXYZ(e,it.x,it.y,it.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)it.fromBufferAttribute(this,e),it.applyNormalMatrix(t),this.setXYZ(e,it.x,it.y,it.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)it.fromBufferAttribute(this,e),it.transformDirection(t),this.setXYZ(e,it.x,it.y,it.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let i=this.array[t*this.itemSize+e];return this.normalized&&(i=Vt(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=J(i,this.array)),this.array[t*this.itemSize+e]=i,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Vt(e,this.array)),e}setX(t,e){return this.normalized&&(e=J(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Vt(e,this.array)),e}setY(t,e){return this.normalized&&(e=J(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Vt(e,this.array)),e}setZ(t,e){return this.normalized&&(e=J(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Vt(e,this.array)),e}setW(t,e){return this.normalized&&(e=J(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=J(e,this.array),i=J(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,s){return t*=this.itemSize,this.normalized&&(e=J(e,this.array),i=J(i,this.array),s=J(s,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t*=this.itemSize,this.normalized&&(e=J(e,this.array),i=J(i,this.array),s=J(s,this.array),n=J(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this.array[t+3]=n,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==35044&&(t.usage=this.usage),t}}class xh extends xt{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class gh extends xt{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class U extends xt{constructor(t,e,i){super(new Float32Array(t),e,i)}}let wh=0;const Tt=new N,En=new X,Ge=new M,_t=new Y,xi=new Y,at=new M;class $ extends $i{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:wh++}),this.uuid=kt(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(nh(t)?gh:xh)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const n=new Ut().getNormalMatrix(t);i.applyNormalMatrix(n),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(t),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Tt.makeRotationFromQuaternion(t),this.applyMatrix4(Tt),this}rotateX(t){return Tt.makeRotationX(t),this.applyMatrix4(Tt),this}rotateY(t){return Tt.makeRotationY(t),this.applyMatrix4(Tt),this}rotateZ(t){return Tt.makeRotationZ(t),this.applyMatrix4(Tt),this}translate(t,e,i){return Tt.makeTranslation(t,e,i),this.applyMatrix4(Tt),this}scale(t,e,i){return Tt.makeScale(t,e,i),this.applyMatrix4(Tt),this}lookAt(t){return En.lookAt(t),En.updateMatrix(),this.applyMatrix4(En.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ge).negate(),this.translate(Ge.x,Ge.y,Ge.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const i=[];for(let s=0,n=t.length;s<n;s++){const r=t[s];i.push(r.x,r.y,r.z||0)}this.setAttribute("position",new U(i,3))}else{for(let i=0,s=e.count;i<s;i++){const n=t[i];e.setXYZ(i,n.x,n.y,n.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Y);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new M(-1/0,-1/0,-1/0),new M(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,s=e.length;i<s;i++){const n=e[i];_t.setFromBufferAttribute(n),this.morphTargetsRelative?(at.addVectors(this.boundingBox.min,_t.min),this.boundingBox.expandByPoint(at),at.addVectors(this.boundingBox.max,_t.max),this.boundingBox.expandByPoint(at)):(this.boundingBox.expandByPoint(_t.min),this.boundingBox.expandByPoint(_t.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ht);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new M,1/0);return}if(t){const i=this.boundingSphere.center;if(_t.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const o=e[n];xi.setFromBufferAttribute(o),this.morphTargetsRelative?(at.addVectors(_t.min,xi.min),_t.expandByPoint(at),at.addVectors(_t.max,xi.max),_t.expandByPoint(at)):(_t.expandByPoint(xi.min),_t.expandByPoint(xi.max))}_t.getCenter(i);let s=0;for(let n=0,r=t.count;n<r;n++)at.fromBufferAttribute(t,n),s=Math.max(s,i.distanceToSquared(at));if(e)for(let n=0,r=e.length;n<r;n++){const o=e[n],a=this.morphTargetsRelative;for(let c=0,l=o.count;c<l;c++)at.fromBufferAttribute(o,c),a&&(Ge.fromBufferAttribute(t,c),at.add(Ge)),s=Math.max(s,i.distanceToSquared(at))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.position,s=e.normal,n=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new xt(new Float32Array(4*i.count),4));const r=this.getAttribute("tangent"),o=[],a=[];for(let _=0;_<i.count;_++)o[_]=new M,a[_]=new M;const c=new M,l=new M,f=new M,u=new P,p=new P,d=new P,y=new M,m=new M;function x(_,z,T){c.fromBufferAttribute(i,_),l.fromBufferAttribute(i,z),f.fromBufferAttribute(i,T),u.fromBufferAttribute(n,_),p.fromBufferAttribute(n,z),d.fromBufferAttribute(n,T),l.sub(c),f.sub(c),p.sub(u),d.sub(u);const I=1/(p.x*d.y-d.x*p.y);isFinite(I)&&(y.copy(l).multiplyScalar(d.y).addScaledVector(f,-p.y).multiplyScalar(I),m.copy(f).multiplyScalar(p.x).addScaledVector(l,-d.x).multiplyScalar(I),o[_].add(y),o[z].add(y),o[T].add(y),a[_].add(m),a[z].add(m),a[T].add(m))}let g=this.groups;g.length===0&&(g=[{start:0,count:t.count}]);for(let _=0,z=g.length;_<z;++_){const T=g[_],I=T.start,C=T.count;for(let B=I,F=I+C;B<F;B+=3)x(t.getX(B+0),t.getX(B+1),t.getX(B+2))}const w=new M,b=new M,v=new M,S=new M;function A(_){v.fromBufferAttribute(s,_),S.copy(v);const z=o[_];w.copy(z),w.sub(v.multiplyScalar(v.dot(z))).normalize(),b.crossVectors(S,z);const I=b.dot(a[_])<0?-1:1;r.setXYZW(_,w.x,w.y,w.z,I)}for(let _=0,z=g.length;_<z;++_){const T=g[_],I=T.start,C=T.count;for(let B=I,F=I+C;B<F;B+=3)A(t.getX(B+0)),A(t.getX(B+1)),A(t.getX(B+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new xt(new Float32Array(e.count*3),3),this.setAttribute("normal",i);else for(let u=0,p=i.count;u<p;u++)i.setXYZ(u,0,0,0);const s=new M,n=new M,r=new M,o=new M,a=new M,c=new M,l=new M,f=new M;if(t)for(let u=0,p=t.count;u<p;u+=3){const d=t.getX(u+0),y=t.getX(u+1),m=t.getX(u+2);s.fromBufferAttribute(e,d),n.fromBufferAttribute(e,y),r.fromBufferAttribute(e,m),l.subVectors(r,n),f.subVectors(s,n),l.cross(f),o.fromBufferAttribute(i,d),a.fromBufferAttribute(i,y),c.fromBufferAttribute(i,m),o.add(l),a.add(l),c.add(l),i.setXYZ(d,o.x,o.y,o.z),i.setXYZ(y,a.x,a.y,a.z),i.setXYZ(m,c.x,c.y,c.z)}else for(let u=0,p=e.count;u<p;u+=3)s.fromBufferAttribute(e,u+0),n.fromBufferAttribute(e,u+1),r.fromBufferAttribute(e,u+2),l.subVectors(r,n),f.subVectors(s,n),l.cross(f),i.setXYZ(u+0,l.x,l.y,l.z),i.setXYZ(u+1,l.x,l.y,l.z),i.setXYZ(u+2,l.x,l.y,l.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)at.fromBufferAttribute(t,e),at.normalize(),t.setXYZ(e,at.x,at.y,at.z)}toNonIndexed(){function t(o,a){const c=o.array,l=o.itemSize,f=o.normalized,u=new c.constructor(a.length*l);let p=0,d=0;for(let y=0,m=a.length;y<m;y++){o.isInterleavedBufferAttribute?p=a[y]*o.data.stride+o.offset:p=a[y]*l;for(let x=0;x<l;x++)u[d++]=c[p++]}return new xt(u,l,f)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new $,i=this.index.array,s=this.attributes;for(const o in s){const a=s[o],c=t(a,i);e.setAttribute(o,c)}const n=this.morphAttributes;for(const o in n){const a=[],c=n[o];for(let l=0,f=c.length;l<f;l++){const u=c[l],p=t(u,i);a.push(p)}e.morphAttributes[o]=a}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let o=0,a=r.length;o<a;o++){const c=r[o];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const c in a)a[c]!==void 0&&(t[c]=a[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const a in i){const c=i[a];t.data.attributes[a]=c.toJSON(t.data)}const s={};let n=!1;for(const a in this.morphAttributes){const c=this.morphAttributes[a],l=[];for(let f=0,u=c.length;f<u;f++){const p=c[f];l.push(p.toJSON(t.data))}l.length>0&&(s[a]=l,n=!0)}n&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const s=t.attributes;for(const c in s){const l=s[c];this.setAttribute(c,l.clone(e))}const n=t.morphAttributes;for(const c in n){const l=[],f=n[c];for(let u=0,p=f.length;u<p;u++)l.push(f[u].clone(e));this.morphAttributes[c]=l}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let c=0,l=r.length;c<l;c++){const f=r[c];this.addGroup(f.start,f.count,f.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=t.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const bo=new N,ve=new Ve,ns=new ht,Mo=new M,rs=new M,os=new M,as=new M,Rn=new M,hs=new M,vo=new M,cs=new M;class Kt extends X{constructor(t=new $,e=new wo){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const o=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=n}}}}getVertexPosition(t,e){const i=this.geometry,s=i.attributes.position,n=i.morphAttributes.position,r=i.morphTargetsRelative;e.fromBufferAttribute(s,t);const o=this.morphTargetInfluences;if(n&&o){hs.set(0,0,0);for(let a=0,c=n.length;a<c;a++){const l=o[a],f=n[a];l!==0&&(Rn.fromBufferAttribute(f,t),r?hs.addScaledVector(Rn,l):hs.addScaledVector(Rn.sub(e),l))}e.add(hs)}return e}raycast(t,e){const i=this.geometry,s=this.material,n=this.matrixWorld;s!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),ns.copy(i.boundingSphere),ns.applyMatrix4(n),ve.copy(t.ray).recast(t.near),!(ns.containsPoint(ve.origin)===!1&&(ve.intersectSphere(ns,Mo)===null||ve.origin.distanceToSquared(Mo)>(t.far-t.near)**2))&&(bo.copy(n).invert(),ve.copy(t.ray).applyMatrix4(bo),!(i.boundingBox!==null&&ve.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(t,e,ve)))}_computeIntersections(t,e,i){let s;const n=this.geometry,r=this.material,o=n.index,a=n.attributes.position,c=n.attributes.uv,l=n.attributes.uv1,f=n.attributes.normal,u=n.groups,p=n.drawRange;if(o!==null)if(Array.isArray(r))for(let d=0,y=u.length;d<y;d++){const m=u[d],x=r[m.materialIndex],g=Math.max(m.start,p.start),w=Math.min(o.count,Math.min(m.start+m.count,p.start+p.count));for(let b=g,v=w;b<v;b+=3){const S=o.getX(b),A=o.getX(b+1),_=o.getX(b+2);s=ls(this,x,t,i,c,l,f,S,A,_),s&&(s.faceIndex=Math.floor(b/3),s.face.materialIndex=m.materialIndex,e.push(s))}}else{const d=Math.max(0,p.start),y=Math.min(o.count,p.start+p.count);for(let m=d,x=y;m<x;m+=3){const g=o.getX(m),w=o.getX(m+1),b=o.getX(m+2);s=ls(this,r,t,i,c,l,f,g,w,b),s&&(s.faceIndex=Math.floor(m/3),e.push(s))}}else if(a!==void 0)if(Array.isArray(r))for(let d=0,y=u.length;d<y;d++){const m=u[d],x=r[m.materialIndex],g=Math.max(m.start,p.start),w=Math.min(a.count,Math.min(m.start+m.count,p.start+p.count));for(let b=g,v=w;b<v;b+=3){const S=b,A=b+1,_=b+2;s=ls(this,x,t,i,c,l,f,S,A,_),s&&(s.faceIndex=Math.floor(b/3),s.face.materialIndex=m.materialIndex,e.push(s))}}else{const d=Math.max(0,p.start),y=Math.min(a.count,p.start+p.count);for(let m=d,x=y;m<x;m+=3){const g=m,w=m+1,b=m+2;s=ls(this,r,t,i,c,l,f,g,w,b),s&&(s.faceIndex=Math.floor(m/3),e.push(s))}}}}function bh(h,t,e,i,s,n,r,o){let a;if(t.side===1?a=i.intersectTriangle(r,n,s,!0,o):a=i.intersectTriangle(s,n,r,t.side===0,o),a===null)return null;cs.copy(o),cs.applyMatrix4(h.matrixWorld);const c=e.ray.origin.distanceTo(cs);return c<e.near||c>e.far?null:{distance:c,point:cs.clone(),object:h}}function ls(h,t,e,i,s,n,r,o,a,c){h.getVertexPosition(o,rs),h.getVertexPosition(a,os),h.getVertexPosition(c,as);const l=bh(h,t,e,i,rs,os,as,vo);if(l){const f=new M;ot.getBarycoord(vo,rs,os,as,f),s&&(l.uv=ot.getInterpolatedAttribute(s,o,a,c,f,new P)),n&&(l.uv1=ot.getInterpolatedAttribute(n,o,a,c,f,new P)),r&&(l.normal=ot.getInterpolatedAttribute(r,o,a,c,f,new M),l.normal.dot(i.direction)>0&&l.normal.multiplyScalar(-1));const u={a:o,b:a,c,normal:new M,materialIndex:0};ot.getNormal(rs,os,as,u.normal),l.face=u,l.barycoord=f}return l}class Ln extends ${constructor(t=1,e=1,i=1,s=1,n=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:s,heightSegments:n,depthSegments:r};const o=this;s=Math.floor(s),n=Math.floor(n),r=Math.floor(r);const a=[],c=[],l=[],f=[];let u=0,p=0;d("z","y","x",-1,-1,i,e,t,r,n,0),d("z","y","x",1,-1,i,e,-t,r,n,1),d("x","z","y",1,1,t,i,e,s,r,2),d("x","z","y",1,-1,t,i,-e,s,r,3),d("x","y","z",1,-1,t,e,i,s,n,4),d("x","y","z",-1,-1,t,e,-i,s,n,5),this.setIndex(a),this.setAttribute("position",new U(c,3)),this.setAttribute("normal",new U(l,3)),this.setAttribute("uv",new U(f,2));function d(y,m,x,g,w,b,v,S,A,_,z){const T=b/A,I=v/_,C=b/2,B=v/2,F=S/2,O=A+1,D=_+1;let et=0,lt=0;const G=new M;for(let nt=0;nt<D;nt++){const j=nt*I-B;for(let Dt=0;Dt<O;Dt++){const Fe=Dt*T-C;G[y]=Fe*g,G[m]=j*w,G[x]=F,c.push(G.x,G.y,G.z),G[y]=0,G[m]=0,G[x]=S>0?1:-1,l.push(G.x,G.y,G.z),f.push(Dt/A),f.push(1-nt/_),et+=1}}for(let nt=0;nt<_;nt++)for(let j=0;j<A;j++){const Dt=u+j+O*nt,Fe=u+j+O*(nt+1),Yr=u+(j+1)+O*(nt+1),un=u+(j+1)+O*nt;a.push(Dt,Fe,un),a.push(Fe,Yr,un),lt+=6}o.addGroup(p,lt,z),p+=lt,u+=et}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Ln(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Mh(h){const t={};for(const e in h){t[e]={};for(const i in h[e]){const s=h[e][i];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][i]=null):t[e][i]=s.clone():Array.isArray(s)?t[e][i]=s.slice():t[e][i]=s}}return t}function vh(h){const t=[];for(let e=0;e<h.length;e++)t.push(h[e].clone());return t}var Sh=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Ah=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class So extends yt{static get type(){return"ShaderMaterial"}constructor(t){super(),this.isShaderMaterial=!0,this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=Sh,this.fragmentShader=Ah,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Mh(t.uniforms),this.uniformsGroups=vh(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const s in this.uniforms){const r=this.uniforms[s].value;r&&r.isTexture?e.uniforms[s]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[s]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[s]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[s]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[s]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[s]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[s]={type:"m4",value:r.toArray()}:e.uniforms[s]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const i={};for(const s in this.extensions)this.extensions[s]===!0&&(i[s]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}class Ao extends X{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new N,this.projectionMatrix=new N,this.projectionMatrixInverse=new N,this.coordinateSystem=2e3}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const fe=new M,_o=new P,zo=new P;class On extends Ao{constructor(t=50,e=1,i=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=dn*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Xi*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return dn*2*Math.atan(Math.tan(Xi*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,i){fe.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(fe.x,fe.y).multiplyScalar(-t/fe.z),fe.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(fe.x,fe.y).multiplyScalar(-t/fe.z)}getViewSize(t,e){return this.getViewBounds(t,_o,zo),e.subVectors(zo,_o)}setViewOffset(t,e,i,s,n,r){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Xi*.5*this.fov)/this.zoom,i=2*e,s=this.aspect*i,n=-.5*s;const r=this.view;if(this.view!==null&&this.view.enabled){const a=r.fullWidth,c=r.fullHeight;n+=r.offsetX*s/a,e-=r.offsetY*i/c,s*=r.width/a,i*=r.height/c}const o=this.filmOffset;o!==0&&(n+=t*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+s,e,e-i,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}class _h extends Wt{constructor(t,e,i,s,n,r,o,a,c,l){t=t!==void 0?t:[],e=e!==void 0?e:301,super(t,e,i,s,n,r,o,a,c,l),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}const Nn=new M,zh=new M,Th=new Ut;class pe{constructor(t=new M(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,s){return this.normal.set(t,e,i),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const s=Nn.subVectors(i,e).cross(zh.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const i=t.delta(Nn),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const n=-(t.start.dot(this.normal)+this.constant)/s;return n<0||n>1?null:e.copy(t.start).addScaledVector(i,n)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||Th.getNormalMatrix(t),s=this.coplanarPoint(Nn).applyMatrix4(t),n=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(n),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Se=new ht,us=new M;class To{constructor(t=new pe,e=new pe,i=new pe,s=new pe,n=new pe,r=new pe){this.planes=[t,e,i,s,n,r]}set(t,e,i,s,n,r){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(i),o[3].copy(s),o[4].copy(n),o[5].copy(r),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t,e=2e3){const i=this.planes,s=t.elements,n=s[0],r=s[1],o=s[2],a=s[3],c=s[4],l=s[5],f=s[6],u=s[7],p=s[8],d=s[9],y=s[10],m=s[11],x=s[12],g=s[13],w=s[14],b=s[15];if(i[0].setComponents(a-n,u-c,m-p,b-x).normalize(),i[1].setComponents(a+n,u+c,m+p,b+x).normalize(),i[2].setComponents(a+r,u+l,m+d,b+g).normalize(),i[3].setComponents(a-r,u-l,m-d,b-g).normalize(),i[4].setComponents(a-o,u-f,m-y,b-w).normalize(),e===2e3)i[5].setComponents(a+o,u+f,m+y,b+w).normalize();else if(e===2001)i[5].setComponents(o,f,y,w).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),Se.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),Se.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Se)}intersectsSprite(t){return Se.center.set(0,0,0),Se.radius=.7071067811865476,Se.applyMatrix4(t.matrixWorld),this.intersectsSphere(Se)}intersectsSphere(t){const e=this.planes,i=t.center,s=-t.radius;for(let n=0;n<6;n++)if(e[n].distanceToPoint(i)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const s=e[i];if(us.x=s.normal.x>0?t.max.x:t.min.x,us.y=s.normal.y>0?t.max.y:t.min.y,us.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(us)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class Dn extends ${constructor(t=1,e=1,i=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:s};const n=t/2,r=e/2,o=Math.floor(i),a=Math.floor(s),c=o+1,l=a+1,f=t/o,u=e/a,p=[],d=[],y=[],m=[];for(let x=0;x<l;x++){const g=x*u-r;for(let w=0;w<c;w++){const b=w*f-n;d.push(b,-g,0),y.push(0,0,1),m.push(w/o),m.push(1-x/a)}}for(let x=0;x<a;x++)for(let g=0;g<o;g++){const w=g+c*x,b=g+c*(x+1),v=g+1+c*(x+1),S=g+1+c*x;p.push(w,b,S),p.push(b,v,S)}this.setIndex(p),this.setAttribute("position",new U(d,3)),this.setAttribute("normal",new U(y,3)),this.setAttribute("uv",new U(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Dn(t.width,t.height,t.widthSegments,t.heightSegments)}}class Co extends Ao{constructor(t=-1,e=1,i=1,s=-1,n=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=s,this.near=n,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,s,n,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let n=i-t,r=i+t,o=s+e,a=s-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,l=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=c*this.view.offsetX,r=n+c*this.view.width,o-=l*this.view.offsetY,a=o-l*this.view.height}this.projectionMatrix.makeOrthographic(n,r,o,a,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class Ch extends yt{static get type(){return"MeshDepthMaterial"}constructor(t){super(),this.isMeshDepthMaterial=!0,this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class Ih extends yt{static get type(){return"MeshDistanceMaterial"}constructor(t){super(),this.isMeshDistanceMaterial=!0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}class Bh extends X{constructor(){super(),this.isGroup=!0,this.type="Group"}}class Vn{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new q(t),this.density=e}clone(){return new Vn(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Un{constructor(t,e=1,i=1e3){this.isFog=!0,this.name="",this.color=new q(t),this.near=e,this.far=i}clone(){return new Un(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Io extends X{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new qt,this.environmentIntensity=1,this.environmentRotation=new qt,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class Bo{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=35044,this.updateRanges=[],this.version=0,this.uuid=kt()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let s=0,n=this.stride;s<n;s++)this.array[t+s]=e.array[i+s];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=kt()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=kt()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const gt=new M;class $e{constructor(t,e,i,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=s}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)gt.fromBufferAttribute(this,e),gt.applyMatrix4(t),this.setXYZ(e,gt.x,gt.y,gt.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)gt.fromBufferAttribute(this,e),gt.applyNormalMatrix(t),this.setXYZ(e,gt.x,gt.y,gt.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)gt.fromBufferAttribute(this,e),gt.transformDirection(t),this.setXYZ(e,gt.x,gt.y,gt.z);return this}getComponent(t,e){let i=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(i=Vt(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=J(i,this.array)),this.data.array[t*this.data.stride+this.offset+e]=i,this}setX(t,e){return this.normalized&&(e=J(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=J(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=J(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=J(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Vt(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Vt(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Vt(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Vt(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=J(e,this.array),i=J(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=J(e,this.array),i=J(i,this.array),s=J(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=J(e,this.array),i=J(i,this.array),s=J(s,this.array),n=J(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this.data.array[t+3]=n,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return new xt(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new $e(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Po extends yt{static get type(){return"SpriteMaterial"}constructor(t){super(),this.isSpriteMaterial=!0,this.color=new q(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let Xe;const gi=new M,Ze=new M,Ye=new M,Qe=new P,wi=new P,Fo=new N,fs=new M,bi=new M,ps=new M,ko=new P,Wn=new P,Eo=new P;class Ph extends X{constructor(t=new Po){if(super(),this.isSprite=!0,this.type="Sprite",Xe===void 0){Xe=new $;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new Bo(e,5);Xe.setIndex([0,1,2,0,2,3]),Xe.setAttribute("position",new $e(i,3,0,!1)),Xe.setAttribute("uv",new $e(i,2,3,!1))}this.geometry=Xe,this.material=t,this.center=new P(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ze.setFromMatrixScale(this.matrixWorld),Fo.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Ye.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Ze.multiplyScalar(-Ye.z);const i=this.material.rotation;let s,n;i!==0&&(n=Math.cos(i),s=Math.sin(i));const r=this.center;ds(fs.set(-.5,-.5,0),Ye,r,Ze,s,n),ds(bi.set(.5,-.5,0),Ye,r,Ze,s,n),ds(ps.set(.5,.5,0),Ye,r,Ze,s,n),ko.set(0,0),Wn.set(1,0),Eo.set(1,1);let o=t.ray.intersectTriangle(fs,bi,ps,!1,gi);if(o===null&&(ds(bi.set(-.5,.5,0),Ye,r,Ze,s,n),Wn.set(0,1),o=t.ray.intersectTriangle(fs,ps,bi,!1,gi),o===null))return;const a=t.ray.origin.distanceTo(gi);a<t.near||a>t.far||e.push({distance:a,point:gi.clone(),uv:ot.getInterpolation(gi,fs,bi,ps,ko,Wn,Eo,new P),face:null,object:this})}copy(t,e){return super.copy(t,e),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}function ds(h,t,e,i,s,n){Qe.subVectors(h,e).addScalar(.5).multiply(i),s!==void 0?(wi.x=n*Qe.x-s*Qe.y,wi.y=s*Qe.x+n*Qe.y):wi.copy(Qe),h.copy(t),h.x+=wi.x,h.y+=wi.y,h.applyMatrix4(Fo)}const ms=new M,Ro=new M;class Fh extends X{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let i=0,s=e.length;i<s;i++){const n=e[i];this.addLevel(n.object.clone(),n.distance,n.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,i=0){e=Math.abs(e);const s=this.levels;let n;for(n=0;n<s.length&&!(e<s[n].distance);n++);return s.splice(n,0,{distance:e,hysteresis:i,object:t}),this.add(t),this}removeLevel(t){const e=this.levels;for(let i=0;i<e.length;i++)if(e[i].distance===t){const s=e.splice(i,1);return this.remove(s[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let i,s;for(i=1,s=e.length;i<s;i++){let n=e[i].distance;if(e[i].object.visible&&(n-=n*e[i].hysteresis),t<n)break}return e[i-1].object}return null}raycast(t,e){if(this.levels.length>0){ms.setFromMatrixPosition(this.matrixWorld);const s=t.ray.origin.distanceTo(ms);this.getObjectForDistance(s).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){ms.setFromMatrixPosition(t.matrixWorld),Ro.setFromMatrixPosition(this.matrixWorld);const i=ms.distanceTo(Ro)/t.zoom;e[0].object.visible=!0;let s,n;for(s=1,n=e.length;s<n;s++){let r=e[s].distance;if(e[s].object.visible&&(r-=r*e[s].hysteresis),i>=r)e[s-1].object.visible=!1,e[s].object.visible=!0;else break}for(this._currentLevel=s-1;s<n;s++)e[s].object.visible=!1}}toJSON(t){const e=super.toJSON(t);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const i=this.levels;for(let s=0,n=i.length;s<n;s++){const r=i[s];e.object.levels.push({object:r.object.uuid,distance:r.distance,hysteresis:r.hysteresis})}return e}}const Lo=new M,Oo=new pt,No=new pt,kh=new M,Do=new N,ys=new M,qn=new ht,Vo=new N,Hn=new Ve;class Eh extends Kt{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=Kr,this.bindMatrix=new N,this.bindMatrixInverse=new N,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;this.boundingBox===null&&(this.boundingBox=new Y),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,ys),this.boundingBox.expandByPoint(ys)}computeBoundingSphere(){const t=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new ht),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,ys),this.boundingSphere.expandByPoint(ys)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const i=this.material,s=this.matrixWorld;i!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),qn.copy(this.boundingSphere),qn.applyMatrix4(s),t.ray.intersectsSphere(qn)!==!1&&(Vo.copy(s).invert(),Hn.copy(t.ray).applyMatrix4(Vo),!(this.boundingBox!==null&&Hn.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(t,e,Hn)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new pt,e=this.geometry.attributes.skinWeight;for(let i=0,s=e.count;i<s;i++){t.fromBufferAttribute(e,i);const n=1/t.manhattanLength();n!==1/0?t.multiplyScalar(n):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===Kr?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===ih?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const i=this.skeleton,s=this.geometry;Oo.fromBufferAttribute(s.attributes.skinIndex,t),No.fromBufferAttribute(s.attributes.skinWeight,t),Lo.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let n=0;n<4;n++){const r=No.getComponent(n);if(r!==0){const o=Oo.getComponent(n);Do.multiplyMatrices(i.bones[o].matrixWorld,i.boneInverses[o]),e.addScaledVector(kh.copy(Lo).applyMatrix4(Do),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}class Uo extends X{constructor(){super(),this.isBone=!0,this.type="Bone"}}class de extends Wt{constructor(t=null,e=1,i=1,s,n,r,o,a,c=1003,l=1003,f,u){super(null,r,o,a,c,l,s,n,f,u),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Wo=new N,Rh=new N;class Jn{constructor(t=[],e=[]){this.uuid=kt(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,s=this.bones.length;i<s;i++)this.boneInverses.push(new N)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const i=new N;this.bones[t]&&i.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&i.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,s=this.boneTexture;for(let n=0,r=t.length;n<r;n++){const o=t[n]?t[n].matrixWorld:Rh;Wo.multiplyMatrices(o,e[n]),Wo.toArray(i,n*16)}s!==null&&(s.needsUpdate=!0)}clone(){return new Jn(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new de(e,t,t,1023,1015);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const s=this.bones[e];if(s.name===t)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,s=t.bones.length;i<s;i++){const n=t.bones[i];let r=e[n];r===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",n),r=new Uo),this.bones.push(r),this.boneInverses.push(new N().fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let s=0,n=e.length;s<n;s++){const r=e[s];t.bones.push(r.uuid);const o=i[s];t.boneInverses.push(o.toArray())}return t}}class Mi extends xt{constructor(t,e,i,s=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const Ke=new N,qo=new N,xs=[],Ho=new Y,Lh=new N,vi=new Kt,Si=new ht;class Oh extends Kt{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Mi(new Float32Array(i*16),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let s=0;s<i;s++)this.setMatrixAt(s,Lh)}computeBoundingBox(){const t=this.geometry,e=this.count;this.boundingBox===null&&(this.boundingBox=new Y),t.boundingBox===null&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,Ke),Ho.copy(t.boundingBox).applyMatrix4(Ke),this.boundingBox.union(Ho)}computeBoundingSphere(){const t=this.geometry,e=this.count;this.boundingSphere===null&&(this.boundingSphere=new ht),t.boundingSphere===null&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,Ke),Si.copy(t.boundingSphere).applyMatrix4(Ke),this.boundingSphere.union(Si)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.morphTexture!==null&&(this.morphTexture=t.morphTexture.clone()),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}getMorphAt(t,e){const i=e.morphTargetInfluences,s=this.morphTexture.source.data.data,n=i.length+1,r=t*n+1;for(let o=0;o<i.length;o++)i[o]=s[r+o]}raycast(t,e){const i=this.matrixWorld,s=this.count;if(vi.geometry=this.geometry,vi.material=this.material,vi.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Si.copy(this.boundingSphere),Si.applyMatrix4(i),t.ray.intersectsSphere(Si)!==!1))for(let n=0;n<s;n++){this.getMatrixAt(n,Ke),qo.multiplyMatrices(i,Ke),vi.matrixWorld=qo,vi.raycast(t,xs);for(let r=0,o=xs.length;r<o;r++){const a=xs[r];a.instanceId=n,a.object=this,e.push(a)}xs.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Mi(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}setMorphAt(t,e){const i=e.morphTargetInfluences,s=i.length+1;this.morphTexture===null&&(this.morphTexture=new de(new Float32Array(s*this.count),s,this.count,1028,1015));const n=this.morphTexture.source.data.data;let r=0;for(let c=0;c<i.length;c++)r+=i[c];const o=this.geometry.morphTargetsRelative?1:1-r,a=s*t;n[a]=o,n.set(i,a+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}function Gn(h,t){return h-t}function Nh(h,t){return h.z-t.z}function Dh(h,t){return t.z-h.z}class Vh{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,e,i,s){const n=this.pool,r=this.list;this.index>=n.length&&n.push({start:-1,count:-1,z:-1,index:-1});const o=n[this.index];r.push(o),this.index++,o.start=t,o.count=e,o.z=i,o.index=s}reset(){this.list.length=0,this.index=0}}const Mt=new N,Uh=new q(1,1,1),$n=new To,gs=new Y,Ae=new ht,Ai=new M,Jo=new M,Wh=new M,Xn=new Vh,mt=new Kt,ws=[];function qh(h,t,e=0){const i=t.itemSize;if(h.isInterleavedBufferAttribute||h.array.constructor!==t.array.constructor){const s=h.count;for(let n=0;n<s;n++)for(let r=0;r<i;r++)t.setComponent(n+e,r,h.getComponent(n,r))}else t.array.set(h.array,e*i);t.needsUpdate=!0}function _e(h,t){if(h.constructor!==t.constructor){const e=Math.min(h.length,t.length);for(let i=0;i<e;i++)t[i]=h[i]}else{const e=Math.min(h.length,t.length);t.set(new h.constructor(h.buffer,0,e))}}class _i extends Kt{get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}constructor(t,e,i=e*2,s){super(new $,s),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=t,this._maxVertexCount=e,this._maxIndexCount=i,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}_initMatricesTexture(){let t=Math.sqrt(this._maxInstanceCount*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4),i=new de(e,t,t,1023,1015);this._matricesTexture=i}_initIndirectTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Uint32Array(t*t),i=new de(e,t,t,1029,1014);this._indirectTexture=i}_initColorsTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Float32Array(t*t*4).fill(1),i=new de(e,t,t,1023,1015);i.colorSpace=St.workingColorSpace,this._colorsTexture=i}_initializeGeometry(t){const e=this.geometry,i=this._maxVertexCount,s=this._maxIndexCount;if(this._geometryInitialized===!1){for(const n in t.attributes){const r=t.getAttribute(n),{array:o,itemSize:a,normalized:c}=r,l=new o.constructor(i*a),f=new xt(l,a,c);e.setAttribute(n,f)}if(t.getIndex()!==null){const n=i>65535?new Uint32Array(s):new Uint16Array(s);e.setIndex(new xt(n,1))}this._geometryInitialized=!0}}_validateGeometry(t){const e=this.geometry;if(!!t.getIndex()!=!!e.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const i in e.attributes){if(!t.hasAttribute(i))throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);const s=t.getAttribute(i),n=e.getAttribute(i);if(s.itemSize!==n.itemSize||s.normalized!==n.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Y);const t=this.boundingBox,e=this._instanceInfo;t.makeEmpty();for(let i=0,s=e.length;i<s;i++){if(e[i].active===!1)continue;const n=e[i].geometryIndex;this.getMatrixAt(i,Mt),this.getBoundingBoxAt(n,gs).applyMatrix4(Mt),t.union(gs)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ht);const t=this.boundingSphere,e=this._instanceInfo;t.makeEmpty();for(let i=0,s=e.length;i<s;i++){if(e[i].active===!1)continue;const n=e[i].geometryIndex;this.getMatrixAt(i,Mt),this.getBoundingSphereAt(n,Ae).applyMatrix4(Mt),t.union(Ae)}}addInstance(t){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("BatchedMesh: Maximum item count reached.");const i={visible:!0,active:!0,geometryIndex:t};let s=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(Gn),s=this._availableInstanceIds.shift(),this._instanceInfo[s]=i):(s=this._instanceInfo.length,this._instanceInfo.push(i));const n=this._matricesTexture;Mt.identity().toArray(n.image.data,s*16),n.needsUpdate=!0;const r=this._colorsTexture;return r&&(Uh.toArray(r.image.data,s*4),r.needsUpdate=!0),this._visibilityChanged=!0,s}addGeometry(t,e=-1,i=-1){this._initializeGeometry(t),this._validateGeometry(t);const s={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},n=this._geometryInfo;s.vertexStart=this._nextVertexStart,s.reservedVertexCount=e===-1?t.getAttribute("position").count:e;const r=t.getIndex();if(r!==null&&(s.indexStart=this._nextIndexStart,s.reservedIndexCount=i===-1?r.count:i),s.indexStart!==-1&&s.indexStart+s.reservedIndexCount>this._maxIndexCount||s.vertexStart+s.reservedVertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");let a;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(Gn),a=this._availableGeometryIds.shift(),n[a]=s):(a=this._geometryCount,this._geometryCount++,n.push(s)),this.setGeometryAt(a,t),this._nextIndexStart=s.indexStart+s.reservedIndexCount,this._nextVertexStart=s.vertexStart+s.reservedVertexCount,a}setGeometryAt(t,e){if(t>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(e);const i=this.geometry,s=i.getIndex()!==null,n=i.getIndex(),r=e.getIndex(),o=this._geometryInfo[t];if(s&&r.count>o.reservedIndexCount||e.attributes.position.count>o.reservedVertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const a=o.vertexStart,c=o.reservedVertexCount;o.vertexCount=e.getAttribute("position").count;for(const l in i.attributes){const f=e.getAttribute(l),u=i.getAttribute(l);qh(f,u,a);const p=f.itemSize;for(let d=f.count,y=c;d<y;d++){const m=a+d;for(let x=0;x<p;x++)u.setComponent(m,x,0)}u.needsUpdate=!0,u.addUpdateRange(a*p,c*p)}if(s){const l=o.indexStart,f=o.reservedIndexCount;o.indexCount=e.getIndex().count;for(let u=0;u<r.count;u++)n.setX(l+u,a+r.getX(u));for(let u=r.count,p=f;u<p;u++)n.setX(l+u,a);n.needsUpdate=!0,n.addUpdateRange(l,o.reservedIndexCount)}return o.start=s?o.indexStart:o.vertexStart,o.count=s?o.indexCount:o.vertexCount,o.boundingBox=null,e.boundingBox!==null&&(o.boundingBox=e.boundingBox.clone()),o.boundingSphere=null,e.boundingSphere!==null&&(o.boundingSphere=e.boundingSphere.clone()),this._visibilityChanged=!0,t}deleteGeometry(t){const e=this._geometryInfo;if(t>=e.length||e[t].active===!1)return this;const i=this._instanceInfo;for(let s=0,n=i.length;s<n;s++)i[s].geometryIndex===t&&this.deleteInstance(s);return e[t].active=!1,this._availableGeometryIds.push(t),this._visibilityChanged=!0,this}deleteInstance(t){const e=this._instanceInfo;return t>=e.length||e[t].active===!1?this:(e[t].active=!1,this._availableInstanceIds.push(t),this._visibilityChanged=!0,this)}optimize(){let t=0,e=0;const i=this._geometryInfo,s=i.map((r,o)=>o).sort((r,o)=>i[r].vertexStart-i[o].vertexStart),n=this.geometry;for(let r=0,o=i.length;r<o;r++){const a=s[r],c=i[a];if(c.active!==!1){if(n.index!==null){if(c.indexStart!==e){const{indexStart:l,vertexStart:f,reservedIndexCount:u}=c,p=n.index,d=p.array,y=t-f;for(let m=l;m<l+u;m++)d[m]=d[m]+y;p.array.copyWithin(e,l,l+u),p.addUpdateRange(e,u),c.indexStart=e}e+=c.reservedIndexCount}if(c.vertexStart!==t){const{vertexStart:l,reservedVertexCount:f}=c,u=n.attributes;for(const p in u){const d=u[p],{array:y,itemSize:m}=d;y.copyWithin(t*m,l*m,(l+f)*m),d.addUpdateRange(t*m,f*m)}c.vertexStart=t}t+=c.reservedVertexCount,c.start=n.index?c.indexStart:c.vertexStart,this._nextIndexStart=n.index?c.indexStart+c.reservedIndexCount:0,this._nextVertexStart=c.vertexStart+c.reservedVertexCount}}return this}getBoundingBoxAt(t,e){if(t>=this._geometryCount)return null;const i=this.geometry,s=this._geometryInfo[t];if(s.boundingBox===null){const n=new Y,r=i.index,o=i.attributes.position;for(let a=s.start,c=s.start+s.count;a<c;a++){let l=a;r&&(l=r.getX(l)),n.expandByPoint(Ai.fromBufferAttribute(o,l))}s.boundingBox=n}return e.copy(s.boundingBox),e}getBoundingSphereAt(t,e){if(t>=this._geometryCount)return null;const i=this.geometry,s=this._geometryInfo[t];if(s.boundingSphere===null){const n=new ht;this.getBoundingBoxAt(t,gs),gs.getCenter(n.center);const r=i.index,o=i.attributes.position;let a=0;for(let c=s.start,l=s.start+s.count;c<l;c++){let f=c;r&&(f=r.getX(f)),Ai.fromBufferAttribute(o,f),a=Math.max(a,n.center.distanceToSquared(Ai))}n.radius=Math.sqrt(a),s.boundingSphere=n}return e.copy(s.boundingSphere),e}setMatrixAt(t,e){const i=this._instanceInfo,s=this._matricesTexture,n=this._matricesTexture.image.data;return t>=i.length||i[t].active===!1?this:(e.toArray(n,t*16),s.needsUpdate=!0,this)}getMatrixAt(t,e){const i=this._instanceInfo,s=this._matricesTexture.image.data;return t>=i.length||i[t].active===!1?null:e.fromArray(s,t*16)}setColorAt(t,e){this._colorsTexture===null&&this._initColorsTexture();const i=this._colorsTexture,s=this._colorsTexture.image.data,n=this._instanceInfo;return t>=n.length||n[t].active===!1?this:(e.toArray(s,t*4),i.needsUpdate=!0,this)}getColorAt(t,e){const i=this._colorsTexture.image.data,s=this._instanceInfo;return t>=s.length||s[t].active===!1?null:e.fromArray(i,t*4)}setVisibleAt(t,e){const i=this._instanceInfo;return t>=i.length||i[t].active===!1||i[t].visible===e?this:(i[t].visible=e,this._visibilityChanged=!0,this)}getVisibleAt(t){const e=this._instanceInfo;return t>=e.length||e[t].active===!1?!1:e[t].visible}setGeometryIdAt(t,e){const i=this._instanceInfo,s=this._geometryInfo;return t>=i.length||i[t].active===!1||e>=s.length||s[e].active===!1?null:(i[t].geometryIndex=e,this)}getGeometryIdAt(t){const e=this._instanceInfo;return t>=e.length||e[t].active===!1?-1:e[t].geometryIndex}getGeometryRangeAt(t,e={}){if(t<0||t>=this._geometryCount)return null;const i=this._geometryInfo[t];return e.vertexStart=i.vertexStart,e.vertexCount=i.vertexCount,e.reservedVertexCount=i.reservedVertexCount,e.indexStart=i.indexStart,e.indexCount=i.indexCount,e.reservedIndexCount=i.reservedIndexCount,e.start=i.start,e.count=i.count,e}setInstanceCount(t){const e=this._availableInstanceIds,i=this._instanceInfo;for(e.sort(Gn);e[e.length-1]===i.length;)i.pop(),e.pop();if(t<i.length)throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);const s=new Int32Array(t),n=new Int32Array(t);_e(this._multiDrawCounts,s),_e(this._multiDrawStarts,n),this._multiDrawCounts=s,this._multiDrawStarts=n,this._maxInstanceCount=t;const r=this._indirectTexture,o=this._matricesTexture,a=this._colorsTexture;r.dispose(),this._initIndirectTexture(),_e(r.image.data,this._indirectTexture.image.data),o.dispose(),this._initMatricesTexture(),_e(o.image.data,this._matricesTexture.image.data),a&&(a.dispose(),this._initColorsTexture(),_e(a.image.data,this._colorsTexture.image.data))}setGeometrySize(t,e){const i=[...this._geometryInfo].filter(o=>o.active);if(Math.max(...i.map(o=>o.vertexStart+o.reservedVertexCount))>t)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...i.map(a=>a.indexStart+a.reservedIndexCount))>e)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`);const n=this.geometry;n.dispose(),this._maxVertexCount=t,this._maxIndexCount=e,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new $,this._initializeGeometry(n));const r=this.geometry;n.index&&_e(n.index.array,r.index.array);for(const o in n.attributes)_e(n.attributes[o].array,r.attributes[o].array)}raycast(t,e){const i=this._instanceInfo,s=this._geometryInfo,n=this.matrixWorld,r=this.geometry;mt.material=this.material,mt.geometry.index=r.index,mt.geometry.attributes=r.attributes,mt.geometry.boundingBox===null&&(mt.geometry.boundingBox=new Y),mt.geometry.boundingSphere===null&&(mt.geometry.boundingSphere=new ht);for(let o=0,a=i.length;o<a;o++){if(!i[o].visible||!i[o].active)continue;const c=i[o].geometryIndex,l=s[c];mt.geometry.setDrawRange(l.start,l.count),this.getMatrixAt(o,mt.matrixWorld).premultiply(n),this.getBoundingBoxAt(c,mt.geometry.boundingBox),this.getBoundingSphereAt(c,mt.geometry.boundingSphere),mt.raycast(t,ws);for(let f=0,u=ws.length;f<u;f++){const p=ws[f];p.object=this,p.batchId=o,e.push(p)}ws.length=0}mt.material=null,mt.geometry.index=null,mt.geometry.attributes={},mt.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=t.boundingBox!==null?t.boundingBox.clone():null,this.boundingSphere=t.boundingSphere!==null?t.boundingSphere.clone():null,this._geometryInfo=t._geometryInfo.map(e=>({...e,boundingBox:e.boundingBox!==null?e.boundingBox.clone():null,boundingSphere:e.boundingSphere!==null?e.boundingSphere.clone():null})),this._instanceInfo=t._instanceInfo.map(e=>({...e})),this._maxInstanceCount=t._maxInstanceCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._geometryCount=t._geometryCount,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=t._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null),this}onBeforeRender(t,e,i,s,n){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const r=s.getIndex(),o=r===null?1:r.array.BYTES_PER_ELEMENT,a=this._instanceInfo,c=this._multiDrawStarts,l=this._multiDrawCounts,f=this._geometryInfo,u=this.perObjectFrustumCulled,p=this._indirectTexture,d=p.image.data;u&&(Mt.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse).multiply(this.matrixWorld),$n.setFromProjectionMatrix(Mt,t.coordinateSystem));let y=0;if(this.sortObjects){Mt.copy(this.matrixWorld).invert(),Ai.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Mt),Jo.set(0,0,-1).transformDirection(i.matrixWorld).transformDirection(Mt);for(let g=0,w=a.length;g<w;g++)if(a[g].visible&&a[g].active){const b=a[g].geometryIndex;this.getMatrixAt(g,Mt),this.getBoundingSphereAt(b,Ae).applyMatrix4(Mt);let v=!1;if(u&&(v=!$n.intersectsSphere(Ae)),!v){const S=f[b],A=Wh.subVectors(Ae.center,Ai).dot(Jo);Xn.push(S.start,S.count,A,g)}}const m=Xn.list,x=this.customSort;x===null?m.sort(n.transparent?Dh:Nh):x.call(this,m,i);for(let g=0,w=m.length;g<w;g++){const b=m[g];c[y]=b.start*o,l[y]=b.count,d[y]=b.index,y++}Xn.reset()}else for(let m=0,x=a.length;m<x;m++)if(a[m].visible&&a[m].active){const g=a[m].geometryIndex;let w=!1;if(u&&(this.getMatrixAt(m,Mt),this.getBoundingSphereAt(g,Ae).applyMatrix4(Mt),w=!$n.intersectsSphere(Ae)),!w){const b=f[g];c[y]=b.start*o,l[y]=b.count,d[y]=m,y++}}p.needsUpdate=!0,this._multiDrawCount=y,this._visibilityChanged=!1}onBeforeShadow(t,e,i,s,n,r){this.onBeforeRender(t,null,s,n,r)}}class Zn extends yt{static get type(){return"LineBasicMaterial"}constructor(t){super(),this.isLineBasicMaterial=!0,this.color=new q(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const bs=new M,Ms=new M,Go=new N,zi=new Ve,vs=new ht,Yn=new M,$o=new M;class Qn extends X{constructor(t=new $,e=new Zn){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[0];for(let s=1,n=e.count;s<n;s++)bs.fromBufferAttribute(e,s-1),Ms.fromBufferAttribute(e,s),i[s]=i[s-1],i[s]+=bs.distanceTo(Ms);t.setAttribute("lineDistance",new U(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Line.threshold,r=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),vs.copy(i.boundingSphere),vs.applyMatrix4(s),vs.radius+=n,t.ray.intersectsSphere(vs)===!1)return;Go.copy(s).invert(),zi.copy(t.ray).applyMatrix4(Go);const o=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,c=this.isLineSegments?2:1,l=i.index,u=i.attributes.position;if(l!==null){const p=Math.max(0,r.start),d=Math.min(l.count,r.start+r.count);for(let y=p,m=d-1;y<m;y+=c){const x=l.getX(y),g=l.getX(y+1),w=Ss(this,t,zi,a,x,g);w&&e.push(w)}if(this.isLineLoop){const y=l.getX(d-1),m=l.getX(p),x=Ss(this,t,zi,a,y,m);x&&e.push(x)}}else{const p=Math.max(0,r.start),d=Math.min(u.count,r.start+r.count);for(let y=p,m=d-1;y<m;y+=c){const x=Ss(this,t,zi,a,y,y+1);x&&e.push(x)}if(this.isLineLoop){const y=Ss(this,t,zi,a,d-1,p);y&&e.push(y)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const o=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=n}}}}}function Ss(h,t,e,i,s,n){const r=h.geometry.attributes.position;if(bs.fromBufferAttribute(r,s),Ms.fromBufferAttribute(r,n),e.distanceSqToSegment(bs,Ms,Yn,$o)>i)return;Yn.applyMatrix4(h.matrixWorld);const a=t.ray.origin.distanceTo(Yn);if(!(a<t.near||a>t.far))return{distance:a,point:$o.clone().applyMatrix4(h.matrixWorld),index:s,face:null,faceIndex:null,barycoord:null,object:h}}const Xo=new M,Zo=new M;class Hh extends Qn{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[];for(let s=0,n=e.count;s<n;s+=2)Xo.fromBufferAttribute(e,s),Zo.fromBufferAttribute(e,s+1),i[s]=s===0?0:i[s-1],i[s+1]=i[s]+Xo.distanceTo(Zo);t.setAttribute("lineDistance",new U(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Jh extends Qn{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class Yo extends yt{static get type(){return"PointsMaterial"}constructor(t){super(),this.isPointsMaterial=!0,this.color=new q(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Qo=new N,Kn=new Ve,As=new ht,_s=new M;class Gh extends X{constructor(t=new $,e=new Yo){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Points.threshold,r=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),As.copy(i.boundingSphere),As.applyMatrix4(s),As.radius+=n,t.ray.intersectsSphere(As)===!1)return;Qo.copy(s).invert(),Kn.copy(t.ray).applyMatrix4(Qo);const o=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=o*o,c=i.index,f=i.attributes.position;if(c!==null){const u=Math.max(0,r.start),p=Math.min(c.count,r.start+r.count);for(let d=u,y=p;d<y;d++){const m=c.getX(d);_s.fromBufferAttribute(f,m),Ko(_s,m,a,s,t,e,this)}}else{const u=Math.max(0,r.start),p=Math.min(f.count,r.start+r.count);for(let d=u,y=p;d<y;d++)_s.fromBufferAttribute(f,d),Ko(_s,d,a,s,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const o=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=n}}}}}function Ko(h,t,e,i,s,n,r){const o=Kn.distanceSqToPoint(h);if(o<e){const a=new M;Kn.closestPointToPoint(h,a),a.applyMatrix4(i);const c=s.ray.origin.distanceTo(a);if(c<s.near||c>s.far)return;n.push({distance:c,distanceToRay:Math.sqrt(o),point:a,index:t,face:null,faceIndex:null,barycoord:null,object:r})}}class Ht{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,s=this.getPoint(0),n=0;e.push(0);for(let r=1;r<=t;r++)i=this.getPoint(r/t),n+=i.distanceTo(s),e.push(n),s=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let s=0;const n=i.length;let r;e?r=e:r=t*i[n-1];let o=0,a=n-1,c;for(;o<=a;)if(s=Math.floor(o+(a-o)/2),c=i[s]-r,c<0)o=s+1;else if(c>0)a=s-1;else{a=s;break}if(s=a,i[s]===r)return s/(n-1);const l=i[s],u=i[s+1]-l,p=(r-l)/u;return(s+p)/(n-1)}getTangent(t,e){let s=t-1e-4,n=t+1e-4;s<0&&(s=0),n>1&&(n=1);const r=this.getPoint(s),o=this.getPoint(n),a=e||(r.isVector2?new P:new M);return a.copy(o).sub(r).normalize(),a}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new M,s=[],n=[],r=[],o=new M,a=new N;for(let p=0;p<=t;p++){const d=p/t;s[p]=this.getTangentAt(d,new M)}n[0]=new M,r[0]=new M;let c=Number.MAX_VALUE;const l=Math.abs(s[0].x),f=Math.abs(s[0].y),u=Math.abs(s[0].z);l<=c&&(c=l,i.set(1,0,0)),f<=c&&(c=f,i.set(0,1,0)),u<=c&&i.set(0,0,1),o.crossVectors(s[0],i).normalize(),n[0].crossVectors(s[0],o),r[0].crossVectors(s[0],n[0]);for(let p=1;p<=t;p++){if(n[p]=n[p-1].clone(),r[p]=r[p-1].clone(),o.crossVectors(s[p-1],s[p]),o.length()>Number.EPSILON){o.normalize();const d=Math.acos(rt(s[p-1].dot(s[p]),-1,1));n[p].applyMatrix4(a.makeRotationAxis(o,d))}r[p].crossVectors(s[p],n[p])}if(e===!0){let p=Math.acos(rt(n[0].dot(n[t]),-1,1));p/=t,s[0].dot(o.crossVectors(n[0],n[t]))>0&&(p=-p);for(let d=1;d<=t;d++)n[d].applyMatrix4(a.makeRotationAxis(s[d],p*d)),r[d].crossVectors(s[d],n[d])}return{tangents:s,normals:n,binormals:r}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class jn extends Ht{constructor(t=0,e=0,i=1,s=1,n=0,r=Math.PI*2,o=!1,a=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=s,this.aStartAngle=n,this.aEndAngle=r,this.aClockwise=o,this.aRotation=a}getPoint(t,e=new P){const i=e,s=Math.PI*2;let n=this.aEndAngle-this.aStartAngle;const r=Math.abs(n)<Number.EPSILON;for(;n<0;)n+=s;for(;n>s;)n-=s;n<Number.EPSILON&&(r?n=0:n=s),this.aClockwise===!0&&!r&&(n===s?n=-s:n=n-s);const o=this.aStartAngle+t*n;let a=this.aX+this.xRadius*Math.cos(o),c=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const l=Math.cos(this.aRotation),f=Math.sin(this.aRotation),u=a-this.aX,p=c-this.aY;a=u*l-p*f+this.aX,c=u*f+p*l+this.aY}return i.set(a,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class $h extends jn{constructor(t,e,i,s,n,r){super(t,e,i,i,s,n,r),this.isArcCurve=!0,this.type="ArcCurve"}}function tr(){let h=0,t=0,e=0,i=0;function s(n,r,o,a){h=n,t=o,e=-3*n+3*r-2*o-a,i=2*n-2*r+o+a}return{initCatmullRom:function(n,r,o,a,c){s(r,o,c*(o-n),c*(a-r))},initNonuniformCatmullRom:function(n,r,o,a,c,l,f){let u=(r-n)/c-(o-n)/(c+l)+(o-r)/l,p=(o-r)/l-(a-r)/(l+f)+(a-o)/f;u*=l,p*=l,s(r,o,u,p)},calc:function(n){const r=n*n,o=r*n;return h+t*n+e*r+i*o}}}const zs=new M,er=new tr,ir=new tr,sr=new tr;class Xh extends Ht{constructor(t=[],e=!1,i="centripetal",s=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=s}getPoint(t,e=new M){const i=e,s=this.points,n=s.length,r=(n-(this.closed?0:1))*t;let o=Math.floor(r),a=r-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/n)+1)*n:a===0&&o===n-1&&(o=n-2,a=1);let c,l;this.closed||o>0?c=s[(o-1)%n]:(zs.subVectors(s[0],s[1]).add(s[0]),c=zs);const f=s[o%n],u=s[(o+1)%n];if(this.closed||o+2<n?l=s[(o+2)%n]:(zs.subVectors(s[n-1],s[n-2]).add(s[n-1]),l=zs),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let d=Math.pow(c.distanceToSquared(f),p),y=Math.pow(f.distanceToSquared(u),p),m=Math.pow(u.distanceToSquared(l),p);y<1e-4&&(y=1),d<1e-4&&(d=y),m<1e-4&&(m=y),er.initNonuniformCatmullRom(c.x,f.x,u.x,l.x,d,y,m),ir.initNonuniformCatmullRom(c.y,f.y,u.y,l.y,d,y,m),sr.initNonuniformCatmullRom(c.z,f.z,u.z,l.z,d,y,m)}else this.curveType==="catmullrom"&&(er.initCatmullRom(c.x,f.x,u.x,l.x,this.tension),ir.initCatmullRom(c.y,f.y,u.y,l.y,this.tension),sr.initCatmullRom(c.z,f.z,u.z,l.z,this.tension));return i.set(er.calc(a),ir.calc(a),sr.calc(a)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(s.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const s=this.points[e];t.points.push(s.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(new M().fromArray(s))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function jo(h,t,e,i,s){const n=(i-t)*.5,r=(s-e)*.5,o=h*h,a=h*o;return(2*e-2*i+n+r)*a+(-3*e+3*i-2*n-r)*o+n*h+e}function Zh(h,t){const e=1-h;return e*e*t}function Yh(h,t){return 2*(1-h)*h*t}function Qh(h,t){return h*h*t}function Ti(h,t,e,i){return Zh(h,t)+Yh(h,e)+Qh(h,i)}function Kh(h,t){const e=1-h;return e*e*e*t}function jh(h,t){const e=1-h;return 3*e*e*h*t}function tc(h,t){return 3*(1-h)*h*h*t}function ec(h,t){return h*h*h*t}function Ci(h,t,e,i,s){return Kh(h,t)+jh(h,e)+tc(h,i)+ec(h,s)}class ta extends Ht{constructor(t=new P,e=new P,i=new P,s=new P){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new P){const i=e,s=this.v0,n=this.v1,r=this.v2,o=this.v3;return i.set(Ci(t,s.x,n.x,r.x,o.x),Ci(t,s.y,n.y,r.y,o.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class ic extends Ht{constructor(t=new M,e=new M,i=new M,s=new M){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new M){const i=e,s=this.v0,n=this.v1,r=this.v2,o=this.v3;return i.set(Ci(t,s.x,n.x,r.x,o.x),Ci(t,s.y,n.y,r.y,o.y),Ci(t,s.z,n.z,r.z,o.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class ea extends Ht{constructor(t=new P,e=new P){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new P){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new P){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class sc extends Ht{constructor(t=new M,e=new M){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new M){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new M){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class ia extends Ht{constructor(t=new P,e=new P,i=new P){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new P){const i=e,s=this.v0,n=this.v1,r=this.v2;return i.set(Ti(t,s.x,n.x,r.x),Ti(t,s.y,n.y,r.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class sa extends Ht{constructor(t=new M,e=new M,i=new M){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new M){const i=e,s=this.v0,n=this.v1,r=this.v2;return i.set(Ti(t,s.x,n.x,r.x),Ti(t,s.y,n.y,r.y),Ti(t,s.z,n.z,r.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class na extends Ht{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new P){const i=e,s=this.points,n=(s.length-1)*t,r=Math.floor(n),o=n-r,a=s[r===0?r:r-1],c=s[r],l=s[r>s.length-2?s.length-1:r+1],f=s[r>s.length-3?s.length-1:r+2];return i.set(jo(o,a.x,c.x,l.x,f.x),jo(o,a.y,c.y,l.y,f.y)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(s.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const s=this.points[e];t.points.push(s.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(new P().fromArray(s))}return this}}var Ts=Object.freeze({__proto__:null,ArcCurve:$h,CatmullRomCurve3:Xh,CubicBezierCurve:ta,CubicBezierCurve3:ic,EllipseCurve:jn,LineCurve:ea,LineCurve3:sc,QuadraticBezierCurve:ia,QuadraticBezierCurve3:sa,SplineCurve:na});class nc extends Ht{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const i=t.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Ts[i](e,t))}return this}getPoint(t,e){const i=t*this.getLength(),s=this.getCurveLengths();let n=0;for(;n<s.length;){if(s[n]>=i){const r=s[n]-i,o=this.curves[n],a=o.getLength(),c=a===0?0:1-r/a;return o.getPointAt(c,e)}n++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let i=0,s=this.curves.length;i<s;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let i;for(let s=0,n=this.curves;s<n.length;s++){const r=n[s],o=r.isEllipseCurve?t*2:r.isLineCurve||r.isLineCurve3?1:r.isSplineCurve?t*r.points.length:t,a=r.getPoints(o);for(let c=0;c<a.length;c++){const l=a[c];i&&i.equals(l)||(e.push(l),i=l)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const s=t.curves[e];this.curves.push(s.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){const s=this.curves[e];t.curves.push(s.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const s=t.curves[e];this.curves.push(new Ts[s.type]().fromJSON(s))}return this}}class nr extends nc{constructor(t){super(),this.type="Path",this.currentPoint=new P,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const i=new ea(this.currentPoint.clone(),new P(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,s){const n=new ia(this.currentPoint.clone(),new P(t,e),new P(i,s));return this.curves.push(n),this.currentPoint.set(i,s),this}bezierCurveTo(t,e,i,s,n,r){const o=new ta(this.currentPoint.clone(),new P(t,e),new P(i,s),new P(n,r));return this.curves.push(o),this.currentPoint.set(n,r),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),i=new na(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,s,n,r){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(t+o,e+a,i,s,n,r),this}absarc(t,e,i,s,n,r){return this.absellipse(t,e,i,i,s,n,r),this}ellipse(t,e,i,s,n,r,o,a){const c=this.currentPoint.x,l=this.currentPoint.y;return this.absellipse(t+c,e+l,i,s,n,r,o,a),this}absellipse(t,e,i,s,n,r,o,a){const c=new jn(t,e,i,s,n,r,o,a);if(this.curves.length>0){const f=c.getPoint(0);f.equals(this.currentPoint)||this.lineTo(f.x,f.y)}this.curves.push(c);const l=c.getPoint(1);return this.currentPoint.copy(l),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Cs extends ${constructor(t=[new P(0,-.5),new P(.5,0),new P(0,.5)],e=12,i=0,s=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:i,phiLength:s},e=Math.floor(e),s=rt(s,0,Math.PI*2);const n=[],r=[],o=[],a=[],c=[],l=1/e,f=new M,u=new P,p=new M,d=new M,y=new M;let m=0,x=0;for(let g=0;g<=t.length-1;g++)switch(g){case 0:m=t[g+1].x-t[g].x,x=t[g+1].y-t[g].y,p.x=x*1,p.y=-m,p.z=x*0,y.copy(p),p.normalize(),a.push(p.x,p.y,p.z);break;case t.length-1:a.push(y.x,y.y,y.z);break;default:m=t[g+1].x-t[g].x,x=t[g+1].y-t[g].y,p.x=x*1,p.y=-m,p.z=x*0,d.copy(p),p.x+=y.x,p.y+=y.y,p.z+=y.z,p.normalize(),a.push(p.x,p.y,p.z),y.copy(d)}for(let g=0;g<=e;g++){const w=i+g*l*s,b=Math.sin(w),v=Math.cos(w);for(let S=0;S<=t.length-1;S++){f.x=t[S].x*b,f.y=t[S].y,f.z=t[S].x*v,r.push(f.x,f.y,f.z),u.x=g/e,u.y=S/(t.length-1),o.push(u.x,u.y);const A=a[3*S+0]*b,_=a[3*S+1],z=a[3*S+0]*v;c.push(A,_,z)}}for(let g=0;g<e;g++)for(let w=0;w<t.length-1;w++){const b=w+g*t.length,v=b,S=b+t.length,A=b+t.length+1,_=b+1;n.push(v,S,_),n.push(A,_,S)}this.setIndex(n),this.setAttribute("position",new U(r,3)),this.setAttribute("uv",new U(o,2)),this.setAttribute("normal",new U(c,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Cs(t.points,t.segments,t.phiStart,t.phiLength)}}class rr extends Cs{constructor(t=1,e=1,i=4,s=8){const n=new nr;n.absarc(0,-e/2,t,Math.PI*1.5,0),n.absarc(0,e/2,t,0,Math.PI*.5),super(n.getPoints(i),s),this.type="CapsuleGeometry",this.parameters={radius:t,length:e,capSegments:i,radialSegments:s}}static fromJSON(t){return new rr(t.radius,t.length,t.capSegments,t.radialSegments)}}class or extends ${constructor(t=1,e=32,i=0,s=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:i,thetaLength:s},e=Math.max(3,e);const n=[],r=[],o=[],a=[],c=new M,l=new P;r.push(0,0,0),o.push(0,0,1),a.push(.5,.5);for(let f=0,u=3;f<=e;f++,u+=3){const p=i+f/e*s;c.x=t*Math.cos(p),c.y=t*Math.sin(p),r.push(c.x,c.y,c.z),o.push(0,0,1),l.x=(r[u]/t+1)/2,l.y=(r[u+1]/t+1)/2,a.push(l.x,l.y)}for(let f=1;f<=e;f++)n.push(f,f+1,0);this.setIndex(n),this.setAttribute("position",new U(r,3)),this.setAttribute("normal",new U(o,3)),this.setAttribute("uv",new U(a,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new or(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class Is extends ${constructor(t=1,e=1,i=1,s=32,n=1,r=!1,o=0,a=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:i,radialSegments:s,heightSegments:n,openEnded:r,thetaStart:o,thetaLength:a};const c=this;s=Math.floor(s),n=Math.floor(n);const l=[],f=[],u=[],p=[];let d=0;const y=[],m=i/2;let x=0;g(),r===!1&&(t>0&&w(!0),e>0&&w(!1)),this.setIndex(l),this.setAttribute("position",new U(f,3)),this.setAttribute("normal",new U(u,3)),this.setAttribute("uv",new U(p,2));function g(){const b=new M,v=new M;let S=0;const A=(e-t)/i;for(let _=0;_<=n;_++){const z=[],T=_/n,I=T*(e-t)+t;for(let C=0;C<=s;C++){const B=C/s,F=B*a+o,O=Math.sin(F),D=Math.cos(F);v.x=I*O,v.y=-T*i+m,v.z=I*D,f.push(v.x,v.y,v.z),b.set(O,A,D).normalize(),u.push(b.x,b.y,b.z),p.push(B,1-T),z.push(d++)}y.push(z)}for(let _=0;_<s;_++)for(let z=0;z<n;z++){const T=y[z][_],I=y[z+1][_],C=y[z+1][_+1],B=y[z][_+1];(t>0||z!==0)&&(l.push(T,I,B),S+=3),(e>0||z!==n-1)&&(l.push(I,C,B),S+=3)}c.addGroup(x,S,0),x+=S}function w(b){const v=d,S=new P,A=new M;let _=0;const z=b===!0?t:e,T=b===!0?1:-1;for(let C=1;C<=s;C++)f.push(0,m*T,0),u.push(0,T,0),p.push(.5,.5),d++;const I=d;for(let C=0;C<=s;C++){const F=C/s*a+o,O=Math.cos(F),D=Math.sin(F);A.x=z*D,A.y=m*T,A.z=z*O,f.push(A.x,A.y,A.z),u.push(0,T,0),S.x=O*.5+.5,S.y=D*.5*T+.5,p.push(S.x,S.y),d++}for(let C=0;C<s;C++){const B=v+C,F=I+C;b===!0?l.push(F,F+1,B):l.push(F+1,F,B),_+=3}c.addGroup(x,_,b===!0?1:2),x+=_}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Is(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class ar extends Is{constructor(t=1,e=1,i=32,s=1,n=!1,r=0,o=Math.PI*2){super(0,t,e,i,s,n,r,o),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:i,heightSegments:s,openEnded:n,thetaStart:r,thetaLength:o}}static fromJSON(t){return new ar(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class ze extends ${constructor(t=[],e=[],i=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:i,detail:s};const n=[],r=[];o(s),c(i),l(),this.setAttribute("position",new U(n,3)),this.setAttribute("normal",new U(n.slice(),3)),this.setAttribute("uv",new U(r,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function o(g){const w=new M,b=new M,v=new M;for(let S=0;S<e.length;S+=3)p(e[S+0],w),p(e[S+1],b),p(e[S+2],v),a(w,b,v,g)}function a(g,w,b,v){const S=v+1,A=[];for(let _=0;_<=S;_++){A[_]=[];const z=g.clone().lerp(b,_/S),T=w.clone().lerp(b,_/S),I=S-_;for(let C=0;C<=I;C++)C===0&&_===S?A[_][C]=z:A[_][C]=z.clone().lerp(T,C/I)}for(let _=0;_<S;_++)for(let z=0;z<2*(S-_)-1;z++){const T=Math.floor(z/2);z%2===0?(u(A[_][T+1]),u(A[_+1][T]),u(A[_][T])):(u(A[_][T+1]),u(A[_+1][T+1]),u(A[_+1][T]))}}function c(g){const w=new M;for(let b=0;b<n.length;b+=3)w.x=n[b+0],w.y=n[b+1],w.z=n[b+2],w.normalize().multiplyScalar(g),n[b+0]=w.x,n[b+1]=w.y,n[b+2]=w.z}function l(){const g=new M;for(let w=0;w<n.length;w+=3){g.x=n[w+0],g.y=n[w+1],g.z=n[w+2];const b=m(g)/2/Math.PI+.5,v=x(g)/Math.PI+.5;r.push(b,1-v)}d(),f()}function f(){for(let g=0;g<r.length;g+=6){const w=r[g+0],b=r[g+2],v=r[g+4],S=Math.max(w,b,v),A=Math.min(w,b,v);S>.9&&A<.1&&(w<.2&&(r[g+0]+=1),b<.2&&(r[g+2]+=1),v<.2&&(r[g+4]+=1))}}function u(g){n.push(g.x,g.y,g.z)}function p(g,w){const b=g*3;w.x=t[b+0],w.y=t[b+1],w.z=t[b+2]}function d(){const g=new M,w=new M,b=new M,v=new M,S=new P,A=new P,_=new P;for(let z=0,T=0;z<n.length;z+=9,T+=6){g.set(n[z+0],n[z+1],n[z+2]),w.set(n[z+3],n[z+4],n[z+5]),b.set(n[z+6],n[z+7],n[z+8]),S.set(r[T+0],r[T+1]),A.set(r[T+2],r[T+3]),_.set(r[T+4],r[T+5]),v.copy(g).add(w).add(b).divideScalar(3);const I=m(v);y(S,T+0,g,I),y(A,T+2,w,I),y(_,T+4,b,I)}}function y(g,w,b,v){v<0&&g.x===1&&(r[w]=g.x-1),b.x===0&&b.z===0&&(r[w]=v/2/Math.PI+.5)}function m(g){return Math.atan2(g.z,-g.x)}function x(g){return Math.atan2(-g.y,Math.sqrt(g.x*g.x+g.z*g.z))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ze(t.vertices,t.indices,t.radius,t.details)}}class hr extends ze{constructor(t=1,e=0){const i=(1+Math.sqrt(5))/2,s=1/i,n=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-i,0,-s,i,0,s,-i,0,s,i,-s,-i,0,-s,i,0,s,-i,0,s,i,0,-i,0,-s,i,0,-s,-i,0,s,i,0,s],r=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(n,r,t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new hr(t.radius,t.detail)}}const Bs=new M,Ps=new M,cr=new M,Fs=new ot;class rc extends ${constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},t!==null){const s=Math.pow(10,4),n=Math.cos(Xi*e),r=t.getIndex(),o=t.getAttribute("position"),a=r?r.count:o.count,c=[0,0,0],l=["a","b","c"],f=new Array(3),u={},p=[];for(let d=0;d<a;d+=3){r?(c[0]=r.getX(d),c[1]=r.getX(d+1),c[2]=r.getX(d+2)):(c[0]=d,c[1]=d+1,c[2]=d+2);const{a:y,b:m,c:x}=Fs;if(y.fromBufferAttribute(o,c[0]),m.fromBufferAttribute(o,c[1]),x.fromBufferAttribute(o,c[2]),Fs.getNormal(cr),f[0]=`${Math.round(y.x*s)},${Math.round(y.y*s)},${Math.round(y.z*s)}`,f[1]=`${Math.round(m.x*s)},${Math.round(m.y*s)},${Math.round(m.z*s)}`,f[2]=`${Math.round(x.x*s)},${Math.round(x.y*s)},${Math.round(x.z*s)}`,!(f[0]===f[1]||f[1]===f[2]||f[2]===f[0]))for(let g=0;g<3;g++){const w=(g+1)%3,b=f[g],v=f[w],S=Fs[l[g]],A=Fs[l[w]],_=`${b}_${v}`,z=`${v}_${b}`;z in u&&u[z]?(cr.dot(u[z].normal)<=n&&(p.push(S.x,S.y,S.z),p.push(A.x,A.y,A.z)),u[z]=null):_ in u||(u[_]={index0:c[g],index1:c[w],normal:cr.clone()})}}for(const d in u)if(u[d]){const{index0:y,index1:m}=u[d];Bs.fromBufferAttribute(o,y),Ps.fromBufferAttribute(o,m),p.push(Bs.x,Bs.y,Bs.z),p.push(Ps.x,Ps.y,Ps.z)}this.setAttribute("position",new U(p,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class lr extends nr{constructor(t){super(t),this.uuid=kt(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let i=0,s=this.holes.length;i<s;i++)e[i]=this.holes[i].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const s=t.holes[e];this.holes.push(s.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){const s=this.holes[e];t.holes.push(s.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const s=t.holes[e];this.holes.push(new nr().fromJSON(s))}return this}}const oc={triangulate:function(h,t,e=2){const i=t&&t.length,s=i?t[0]*e:h.length;let n=ra(h,0,s,e,!0);const r=[];if(!n||n.next===n.prev)return r;let o,a,c,l,f,u,p;if(i&&(n=uc(h,t,n,e)),h.length>80*e){o=c=h[0],a=l=h[1];for(let d=e;d<s;d+=e)f=h[d],u=h[d+1],f<o&&(o=f),u<a&&(a=u),f>c&&(c=f),u>l&&(l=u);p=Math.max(c-o,l-a),p=p!==0?32767/p:0}return Ii(n,r,e,o,a,p,0),r}};function ra(h,t,e,i,s){let n,r;if(s===vc(h,t,e,i)>0)for(n=t;n<e;n+=i)r=ha(n,h[n],h[n+1],r);else for(n=e-i;n>=t;n-=i)r=ha(n,h[n],h[n+1],r);return r&&ks(r,r.next)&&(Pi(r),r=r.next),r}function Te(h,t){if(!h)return h;t||(t=h);let e=h,i;do if(i=!1,!e.steiner&&(ks(e,e.next)||Q(e.prev,e,e.next)===0)){if(Pi(e),e=t=e.prev,e===e.next)break;i=!0}else e=e.next;while(i||e!==t);return t}function Ii(h,t,e,i,s,n,r){if(!h)return;!r&&n&&yc(h,i,s,n);let o=h,a,c;for(;h.prev!==h.next;){if(a=h.prev,c=h.next,n?hc(h,i,s,n):ac(h)){t.push(a.i/e|0),t.push(h.i/e|0),t.push(c.i/e|0),Pi(h),h=c.next,o=c.next;continue}if(h=c,h===o){r?r===1?(h=cc(Te(h),t,e),Ii(h,t,e,i,s,n,2)):r===2&&lc(h,t,e,i,s,n):Ii(Te(h),t,e,i,s,n,1);break}}}function ac(h){const t=h.prev,e=h,i=h.next;if(Q(t,e,i)>=0)return!1;const s=t.x,n=e.x,r=i.x,o=t.y,a=e.y,c=i.y,l=s<n?s<r?s:r:n<r?n:r,f=o<a?o<c?o:c:a<c?a:c,u=s>n?s>r?s:r:n>r?n:r,p=o>a?o>c?o:c:a>c?a:c;let d=i.next;for(;d!==t;){if(d.x>=l&&d.x<=u&&d.y>=f&&d.y<=p&&je(s,o,n,a,r,c,d.x,d.y)&&Q(d.prev,d,d.next)>=0)return!1;d=d.next}return!0}function hc(h,t,e,i){const s=h.prev,n=h,r=h.next;if(Q(s,n,r)>=0)return!1;const o=s.x,a=n.x,c=r.x,l=s.y,f=n.y,u=r.y,p=o<a?o<c?o:c:a<c?a:c,d=l<f?l<u?l:u:f<u?f:u,y=o>a?o>c?o:c:a>c?a:c,m=l>f?l>u?l:u:f>u?f:u,x=ur(p,d,t,e,i),g=ur(y,m,t,e,i);let w=h.prevZ,b=h.nextZ;for(;w&&w.z>=x&&b&&b.z<=g;){if(w.x>=p&&w.x<=y&&w.y>=d&&w.y<=m&&w!==s&&w!==r&&je(o,l,a,f,c,u,w.x,w.y)&&Q(w.prev,w,w.next)>=0||(w=w.prevZ,b.x>=p&&b.x<=y&&b.y>=d&&b.y<=m&&b!==s&&b!==r&&je(o,l,a,f,c,u,b.x,b.y)&&Q(b.prev,b,b.next)>=0))return!1;b=b.nextZ}for(;w&&w.z>=x;){if(w.x>=p&&w.x<=y&&w.y>=d&&w.y<=m&&w!==s&&w!==r&&je(o,l,a,f,c,u,w.x,w.y)&&Q(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;b&&b.z<=g;){if(b.x>=p&&b.x<=y&&b.y>=d&&b.y<=m&&b!==s&&b!==r&&je(o,l,a,f,c,u,b.x,b.y)&&Q(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function cc(h,t,e){let i=h;do{const s=i.prev,n=i.next.next;!ks(s,n)&&oa(s,i,i.next,n)&&Bi(s,n)&&Bi(n,s)&&(t.push(s.i/e|0),t.push(i.i/e|0),t.push(n.i/e|0),Pi(i),Pi(i.next),i=h=n),i=i.next}while(i!==h);return Te(i)}function lc(h,t,e,i,s,n){let r=h;do{let o=r.next.next;for(;o!==r.prev;){if(r.i!==o.i&&wc(r,o)){let a=aa(r,o);r=Te(r,r.next),a=Te(a,a.next),Ii(r,t,e,i,s,n,0),Ii(a,t,e,i,s,n,0);return}o=o.next}r=r.next}while(r!==h)}function uc(h,t,e,i){const s=[];let n,r,o,a,c;for(n=0,r=t.length;n<r;n++)o=t[n]*i,a=n<r-1?t[n+1]*i:h.length,c=ra(h,o,a,i,!1),c===c.next&&(c.steiner=!0),s.push(gc(c));for(s.sort(fc),n=0;n<s.length;n++)e=pc(s[n],e);return e}function fc(h,t){return h.x-t.x}function pc(h,t){const e=dc(h,t);if(!e)return t;const i=aa(e,h);return Te(i,i.next),Te(e,e.next)}function dc(h,t){let e=t,i=-1/0,s;const n=h.x,r=h.y;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const u=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(u<=n&&u>i&&(i=u,s=e.x<e.next.x?e:e.next,u===n))return s}e=e.next}while(e!==t);if(!s)return null;const o=s,a=s.x,c=s.y;let l=1/0,f;e=s;do n>=e.x&&e.x>=a&&n!==e.x&&je(r<c?n:i,r,a,c,r<c?i:n,r,e.x,e.y)&&(f=Math.abs(r-e.y)/(n-e.x),Bi(e,h)&&(f<l||f===l&&(e.x>s.x||e.x===s.x&&mc(s,e)))&&(s=e,l=f)),e=e.next;while(e!==o);return s}function mc(h,t){return Q(h.prev,h,t.prev)<0&&Q(t.next,h,h.next)<0}function yc(h,t,e,i){let s=h;do s.z===0&&(s.z=ur(s.x,s.y,t,e,i)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==h);s.prevZ.nextZ=null,s.prevZ=null,xc(s)}function xc(h){let t,e,i,s,n,r,o,a,c=1;do{for(e=h,h=null,n=null,r=0;e;){for(r++,i=e,o=0,t=0;t<c&&(o++,i=i.nextZ,!!i);t++);for(a=c;o>0||a>0&&i;)o!==0&&(a===0||!i||e.z<=i.z)?(s=e,e=e.nextZ,o--):(s=i,i=i.nextZ,a--),n?n.nextZ=s:h=s,s.prevZ=n,n=s;e=i}n.nextZ=null,c*=2}while(r>1);return h}function ur(h,t,e,i,s){return h=(h-e)*s|0,t=(t-i)*s|0,h=(h|h<<8)&16711935,h=(h|h<<4)&252645135,h=(h|h<<2)&858993459,h=(h|h<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,h|t<<1}function gc(h){let t=h,e=h;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==h);return e}function je(h,t,e,i,s,n,r,o){return(s-r)*(t-o)>=(h-r)*(n-o)&&(h-r)*(i-o)>=(e-r)*(t-o)&&(e-r)*(n-o)>=(s-r)*(i-o)}function wc(h,t){return h.next.i!==t.i&&h.prev.i!==t.i&&!bc(h,t)&&(Bi(h,t)&&Bi(t,h)&&Mc(h,t)&&(Q(h.prev,h,t.prev)||Q(h,t.prev,t))||ks(h,t)&&Q(h.prev,h,h.next)>0&&Q(t.prev,t,t.next)>0)}function Q(h,t,e){return(t.y-h.y)*(e.x-t.x)-(t.x-h.x)*(e.y-t.y)}function ks(h,t){return h.x===t.x&&h.y===t.y}function oa(h,t,e,i){const s=Rs(Q(h,t,e)),n=Rs(Q(h,t,i)),r=Rs(Q(e,i,h)),o=Rs(Q(e,i,t));return!!(s!==n&&r!==o||s===0&&Es(h,e,t)||n===0&&Es(h,i,t)||r===0&&Es(e,h,i)||o===0&&Es(e,t,i))}function Es(h,t,e){return t.x<=Math.max(h.x,e.x)&&t.x>=Math.min(h.x,e.x)&&t.y<=Math.max(h.y,e.y)&&t.y>=Math.min(h.y,e.y)}function Rs(h){return h>0?1:h<0?-1:0}function bc(h,t){let e=h;do{if(e.i!==h.i&&e.next.i!==h.i&&e.i!==t.i&&e.next.i!==t.i&&oa(e,e.next,h,t))return!0;e=e.next}while(e!==h);return!1}function Bi(h,t){return Q(h.prev,h,h.next)<0?Q(h,t,h.next)>=0&&Q(h,h.prev,t)>=0:Q(h,t,h.prev)<0||Q(h,h.next,t)<0}function Mc(h,t){let e=h,i=!1;const s=(h.x+t.x)/2,n=(h.y+t.y)/2;do e.y>n!=e.next.y>n&&e.next.y!==e.y&&s<(e.next.x-e.x)*(n-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==h);return i}function aa(h,t){const e=new fr(h.i,h.x,h.y),i=new fr(t.i,t.x,t.y),s=h.next,n=t.prev;return h.next=t,t.prev=h,e.next=s,s.prev=e,i.next=e,e.prev=i,n.next=i,i.prev=n,i}function ha(h,t,e,i){const s=new fr(h,t,e);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s}function Pi(h){h.next.prev=h.prev,h.prev.next=h.next,h.prevZ&&(h.prevZ.nextZ=h.nextZ),h.nextZ&&(h.nextZ.prevZ=h.prevZ)}function fr(h,t,e){this.i=h,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function vc(h,t,e,i){let s=0;for(let n=t,r=e-i;n<e;n+=i)s+=(h[r]-h[n])*(h[n+1]+h[r+1]),r=n;return s}class me{static area(t){const e=t.length;let i=0;for(let s=e-1,n=0;n<e;s=n++)i+=t[s].x*t[n].y-t[n].x*t[s].y;return i*.5}static isClockWise(t){return me.area(t)<0}static triangulateShape(t,e){const i=[],s=[],n=[];ca(t),la(i,t);let r=t.length;e.forEach(ca);for(let a=0;a<e.length;a++)s.push(r),r+=e[a].length,la(i,e[a]);const o=oc.triangulate(i,s);for(let a=0;a<o.length;a+=3)n.push(o.slice(a,a+3));return n}}function ca(h){const t=h.length;t>2&&h[t-1].equals(h[0])&&h.pop()}function la(h,t){for(let e=0;e<t.length;e++)h.push(t[e].x),h.push(t[e].y)}class pr extends ${constructor(t=new lr([new P(.5,.5),new P(-.5,.5),new P(-.5,-.5),new P(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const i=this,s=[],n=[];for(let o=0,a=t.length;o<a;o++){const c=t[o];r(c)}this.setAttribute("position",new U(s,3)),this.setAttribute("uv",new U(n,2)),this.computeVertexNormals();function r(o){const a=[],c=e.curveSegments!==void 0?e.curveSegments:12,l=e.steps!==void 0?e.steps:1,f=e.depth!==void 0?e.depth:1;let u=e.bevelEnabled!==void 0?e.bevelEnabled:!0,p=e.bevelThickness!==void 0?e.bevelThickness:.2,d=e.bevelSize!==void 0?e.bevelSize:p-.1,y=e.bevelOffset!==void 0?e.bevelOffset:0,m=e.bevelSegments!==void 0?e.bevelSegments:3;const x=e.extrudePath,g=e.UVGenerator!==void 0?e.UVGenerator:Sc;let w,b=!1,v,S,A,_;x&&(w=x.getSpacedPoints(l),b=!0,u=!1,v=x.computeFrenetFrames(l,!1),S=new M,A=new M,_=new M),u||(m=0,p=0,d=0,y=0);const z=o.extractPoints(c);let T=z.shape;const I=z.holes;if(!me.isClockWise(T)){T=T.reverse();for(let k=0,E=I.length;k<E;k++){const R=I[k];me.isClockWise(R)&&(I[k]=R.reverse())}}const B=me.triangulateShape(T,I),F=T;for(let k=0,E=I.length;k<E;k++){const R=I[k];T=T.concat(R)}function O(k,E,R){return E||console.error("THREE.ExtrudeGeometry: vec does not exist"),k.clone().addScaledVector(E,R)}const D=T.length,et=B.length;function lt(k,E,R){let V,L,W;const H=k.x-E.x,tt=k.y-E.y,bt=R.x-k.x,ut=R.y-k.y,Ji=H*H+tt*tt,Qr=H*ut-tt*bt;if(Math.abs(Qr)>Number.EPSILON){const oe=Math.sqrt(Ji),Qa=Math.sqrt(bt*bt+ut*ut),Ka=E.x-tt/oe,ja=E.y+H/oe,Su=R.x-ut/Qa,Au=R.y+bt/Qa,th=((Su-Ka)*ut-(Au-ja)*bt)/(H*ut-tt*bt);V=Ka+H*th-k.x,L=ja+tt*th-k.y;const eh=V*V+L*L;if(eh<=2)return new P(V,L);W=Math.sqrt(eh/2)}else{let oe=!1;H>Number.EPSILON?bt>Number.EPSILON&&(oe=!0):H<-Number.EPSILON?bt<-Number.EPSILON&&(oe=!0):Math.sign(tt)===Math.sign(ut)&&(oe=!0),oe?(V=-tt,L=H,W=Math.sqrt(Ji)):(V=H,L=tt,W=Math.sqrt(Ji/2))}return new P(V/W,L/W)}const G=[];for(let k=0,E=F.length,R=E-1,V=k+1;k<E;k++,R++,V++)R===E&&(R=0),V===E&&(V=0),G[k]=lt(F[k],F[R],F[V]);const nt=[];let j,Dt=G.concat();for(let k=0,E=I.length;k<E;k++){const R=I[k];j=[];for(let V=0,L=R.length,W=L-1,H=V+1;V<L;V++,W++,H++)W===L&&(W=0),H===L&&(H=0),j[V]=lt(R[V],R[W],R[H]);nt.push(j),Dt=Dt.concat(j)}for(let k=0;k<m;k++){const E=k/m,R=p*Math.cos(E*Math.PI/2),V=d*Math.sin(E*Math.PI/2)+y;for(let L=0,W=F.length;L<W;L++){const H=O(F[L],G[L],V);se(H.x,H.y,-R)}for(let L=0,W=I.length;L<W;L++){const H=I[L];j=nt[L];for(let tt=0,bt=H.length;tt<bt;tt++){const ut=O(H[tt],j[tt],V);se(ut.x,ut.y,-R)}}}const Fe=d+y;for(let k=0;k<D;k++){const E=u?O(T[k],Dt[k],Fe):T[k];b?(A.copy(v.normals[0]).multiplyScalar(E.x),S.copy(v.binormals[0]).multiplyScalar(E.y),_.copy(w[0]).add(A).add(S),se(_.x,_.y,_.z)):se(E.x,E.y,0)}for(let k=1;k<=l;k++)for(let E=0;E<D;E++){const R=u?O(T[E],Dt[E],Fe):T[E];b?(A.copy(v.normals[k]).multiplyScalar(R.x),S.copy(v.binormals[k]).multiplyScalar(R.y),_.copy(w[k]).add(A).add(S),se(_.x,_.y,_.z)):se(R.x,R.y,f/l*k)}for(let k=m-1;k>=0;k--){const E=k/m,R=p*Math.cos(E*Math.PI/2),V=d*Math.sin(E*Math.PI/2)+y;for(let L=0,W=F.length;L<W;L++){const H=O(F[L],G[L],V);se(H.x,H.y,f+R)}for(let L=0,W=I.length;L<W;L++){const H=I[L];j=nt[L];for(let tt=0,bt=H.length;tt<bt;tt++){const ut=O(H[tt],j[tt],V);b?se(ut.x,ut.y+w[l-1].y,w[l-1].x+R):se(ut.x,ut.y,f+R)}}}Yr(),un();function Yr(){const k=s.length/3;if(u){let E=0,R=D*E;for(let V=0;V<et;V++){const L=B[V];fn(L[2]+R,L[1]+R,L[0]+R)}E=l+m*2,R=D*E;for(let V=0;V<et;V++){const L=B[V];fn(L[0]+R,L[1]+R,L[2]+R)}}else{for(let E=0;E<et;E++){const R=B[E];fn(R[2],R[1],R[0])}for(let E=0;E<et;E++){const R=B[E];fn(R[0]+D*l,R[1]+D*l,R[2]+D*l)}}i.addGroup(k,s.length/3-k,0)}function un(){const k=s.length/3;let E=0;Ya(F,E),E+=F.length;for(let R=0,V=I.length;R<V;R++){const L=I[R];Ya(L,E),E+=L.length}i.addGroup(k,s.length/3-k,1)}function Ya(k,E){let R=k.length;for(;--R>=0;){const V=R;let L=R-1;L<0&&(L=k.length-1);for(let W=0,H=l+m*2;W<H;W++){const tt=D*W,bt=D*(W+1),ut=E+V+tt,Ji=E+L+tt,Qr=E+L+bt,oe=E+V+bt;vu(ut,Ji,Qr,oe)}}}function se(k,E,R){a.push(k),a.push(E),a.push(R)}function fn(k,E,R){ne(k),ne(E),ne(R);const V=s.length/3,L=g.generateTopUV(i,s,V-3,V-2,V-1);re(L[0]),re(L[1]),re(L[2])}function vu(k,E,R,V){ne(k),ne(E),ne(V),ne(E),ne(R),ne(V);const L=s.length/3,W=g.generateSideWallUV(i,s,L-6,L-3,L-2,L-1);re(W[0]),re(W[1]),re(W[3]),re(W[1]),re(W[2]),re(W[3])}function ne(k){s.push(a[k*3+0]),s.push(a[k*3+1]),s.push(a[k*3+2])}function re(k){n.push(k.x),n.push(k.y)}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,i=this.parameters.options;return Ac(e,i,t)}static fromJSON(t,e){const i=[];for(let n=0,r=t.shapes.length;n<r;n++){const o=e[t.shapes[n]];i.push(o)}const s=t.options.extrudePath;return s!==void 0&&(t.options.extrudePath=new Ts[s.type]().fromJSON(s)),new pr(i,t.options)}}const Sc={generateTopUV:function(h,t,e,i,s){const n=t[e*3],r=t[e*3+1],o=t[i*3],a=t[i*3+1],c=t[s*3],l=t[s*3+1];return[new P(n,r),new P(o,a),new P(c,l)]},generateSideWallUV:function(h,t,e,i,s,n){const r=t[e*3],o=t[e*3+1],a=t[e*3+2],c=t[i*3],l=t[i*3+1],f=t[i*3+2],u=t[s*3],p=t[s*3+1],d=t[s*3+2],y=t[n*3],m=t[n*3+1],x=t[n*3+2];return Math.abs(o-l)<Math.abs(r-c)?[new P(r,1-a),new P(c,1-f),new P(u,1-d),new P(y,1-x)]:[new P(o,1-a),new P(l,1-f),new P(p,1-d),new P(m,1-x)]}};function Ac(h,t,e){if(e.shapes=[],Array.isArray(h))for(let i=0,s=h.length;i<s;i++){const n=h[i];e.shapes.push(n.uuid)}else e.shapes.push(h.uuid);return e.options=Object.assign({},t),t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class dr extends ze{constructor(t=1,e=0){const i=(1+Math.sqrt(5))/2,s=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],n=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(s,n,t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new dr(t.radius,t.detail)}}class mr extends ze{constructor(t=1,e=0){const i=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],s=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(i,s,t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new mr(t.radius,t.detail)}}class yr extends ${constructor(t=.5,e=1,i=32,s=1,n=0,r=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:i,phiSegments:s,thetaStart:n,thetaLength:r},i=Math.max(3,i),s=Math.max(1,s);const o=[],a=[],c=[],l=[];let f=t;const u=(e-t)/s,p=new M,d=new P;for(let y=0;y<=s;y++){for(let m=0;m<=i;m++){const x=n+m/i*r;p.x=f*Math.cos(x),p.y=f*Math.sin(x),a.push(p.x,p.y,p.z),c.push(0,0,1),d.x=(p.x/e+1)/2,d.y=(p.y/e+1)/2,l.push(d.x,d.y)}f+=u}for(let y=0;y<s;y++){const m=y*(i+1);for(let x=0;x<i;x++){const g=x+m,w=g,b=g+i+1,v=g+i+2,S=g+1;o.push(w,b,S),o.push(b,v,S)}}this.setIndex(o),this.setAttribute("position",new U(a,3)),this.setAttribute("normal",new U(c,3)),this.setAttribute("uv",new U(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new yr(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class xr extends ${constructor(t=new lr([new P(0,.5),new P(-.5,-.5),new P(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const i=[],s=[],n=[],r=[];let o=0,a=0;if(Array.isArray(t)===!1)c(t);else for(let l=0;l<t.length;l++)c(t[l]),this.addGroup(o,a,l),o+=a,a=0;this.setIndex(i),this.setAttribute("position",new U(s,3)),this.setAttribute("normal",new U(n,3)),this.setAttribute("uv",new U(r,2));function c(l){const f=s.length/3,u=l.extractPoints(e);let p=u.shape;const d=u.holes;me.isClockWise(p)===!1&&(p=p.reverse());for(let m=0,x=d.length;m<x;m++){const g=d[m];me.isClockWise(g)===!0&&(d[m]=g.reverse())}const y=me.triangulateShape(p,d);for(let m=0,x=d.length;m<x;m++){const g=d[m];p=p.concat(g)}for(let m=0,x=p.length;m<x;m++){const g=p[m];s.push(g.x,g.y,0),n.push(0,0,1),r.push(g.x,g.y)}for(let m=0,x=y.length;m<x;m++){const g=y[m],w=g[0]+f,b=g[1]+f,v=g[2]+f;i.push(w,b,v),a+=3}}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return _c(e,t)}static fromJSON(t,e){const i=[];for(let s=0,n=t.shapes.length;s<n;s++){const r=e[t.shapes[s]];i.push(r)}return new xr(i,t.curveSegments)}}function _c(h,t){if(t.shapes=[],Array.isArray(h))for(let e=0,i=h.length;e<i;e++){const s=h[e];t.shapes.push(s.uuid)}else t.shapes.push(h.uuid);return t}class gr extends ${constructor(t=1,e=32,i=16,s=0,n=Math.PI*2,r=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:s,phiLength:n,thetaStart:r,thetaLength:o},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));const a=Math.min(r+o,Math.PI);let c=0;const l=[],f=new M,u=new M,p=[],d=[],y=[],m=[];for(let x=0;x<=i;x++){const g=[],w=x/i;let b=0;x===0&&r===0?b=.5/e:x===i&&a===Math.PI&&(b=-.5/e);for(let v=0;v<=e;v++){const S=v/e;f.x=-t*Math.cos(s+S*n)*Math.sin(r+w*o),f.y=t*Math.cos(r+w*o),f.z=t*Math.sin(s+S*n)*Math.sin(r+w*o),d.push(f.x,f.y,f.z),u.copy(f).normalize(),y.push(u.x,u.y,u.z),m.push(S+b,1-w),g.push(c++)}l.push(g)}for(let x=0;x<i;x++)for(let g=0;g<e;g++){const w=l[x][g+1],b=l[x][g],v=l[x+1][g],S=l[x+1][g+1];(x!==0||r>0)&&p.push(w,b,S),(x!==i-1||a<Math.PI)&&p.push(b,v,S)}this.setIndex(p),this.setAttribute("position",new U(d,3)),this.setAttribute("normal",new U(y,3)),this.setAttribute("uv",new U(m,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new gr(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class wr extends ze{constructor(t=1,e=0){const i=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],s=[2,1,0,0,3,2,1,3,0,2,3,1];super(i,s,t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new wr(t.radius,t.detail)}}class br extends ${constructor(t=1,e=.4,i=12,s=48,n=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:s,arc:n},i=Math.floor(i),s=Math.floor(s);const r=[],o=[],a=[],c=[],l=new M,f=new M,u=new M;for(let p=0;p<=i;p++)for(let d=0;d<=s;d++){const y=d/s*n,m=p/i*Math.PI*2;f.x=(t+e*Math.cos(m))*Math.cos(y),f.y=(t+e*Math.cos(m))*Math.sin(y),f.z=e*Math.sin(m),o.push(f.x,f.y,f.z),l.x=t*Math.cos(y),l.y=t*Math.sin(y),u.subVectors(f,l).normalize(),a.push(u.x,u.y,u.z),c.push(d/s),c.push(p/i)}for(let p=1;p<=i;p++)for(let d=1;d<=s;d++){const y=(s+1)*p+d-1,m=(s+1)*(p-1)+d-1,x=(s+1)*(p-1)+d,g=(s+1)*p+d;r.push(y,m,g),r.push(m,x,g)}this.setIndex(r),this.setAttribute("position",new U(o,3)),this.setAttribute("normal",new U(a,3)),this.setAttribute("uv",new U(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new br(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class Mr extends ${constructor(t=1,e=.4,i=64,s=8,n=2,r=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:i,radialSegments:s,p:n,q:r},i=Math.floor(i),s=Math.floor(s);const o=[],a=[],c=[],l=[],f=new M,u=new M,p=new M,d=new M,y=new M,m=new M,x=new M;for(let w=0;w<=i;++w){const b=w/i*n*Math.PI*2;g(b,n,r,t,p),g(b+.01,n,r,t,d),m.subVectors(d,p),x.addVectors(d,p),y.crossVectors(m,x),x.crossVectors(y,m),y.normalize(),x.normalize();for(let v=0;v<=s;++v){const S=v/s*Math.PI*2,A=-e*Math.cos(S),_=e*Math.sin(S);f.x=p.x+(A*x.x+_*y.x),f.y=p.y+(A*x.y+_*y.y),f.z=p.z+(A*x.z+_*y.z),a.push(f.x,f.y,f.z),u.subVectors(f,p).normalize(),c.push(u.x,u.y,u.z),l.push(w/i),l.push(v/s)}}for(let w=1;w<=i;w++)for(let b=1;b<=s;b++){const v=(s+1)*(w-1)+(b-1),S=(s+1)*w+(b-1),A=(s+1)*w+b,_=(s+1)*(w-1)+b;o.push(v,S,_),o.push(S,A,_)}this.setIndex(o),this.setAttribute("position",new U(a,3)),this.setAttribute("normal",new U(c,3)),this.setAttribute("uv",new U(l,2));function g(w,b,v,S,A){const _=Math.cos(w),z=Math.sin(w),T=v/b*w,I=Math.cos(T);A.x=S*(2+I)*.5*_,A.y=S*(2+I)*z*.5,A.z=S*Math.sin(T)*.5}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Mr(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class vr extends ${constructor(t=new sa(new M(-1,-1,0),new M(-1,1,0),new M(1,1,0)),e=64,i=1,s=8,n=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:i,radialSegments:s,closed:n};const r=t.computeFrenetFrames(e,n);this.tangents=r.tangents,this.normals=r.normals,this.binormals=r.binormals;const o=new M,a=new M,c=new P;let l=new M;const f=[],u=[],p=[],d=[];y(),this.setIndex(d),this.setAttribute("position",new U(f,3)),this.setAttribute("normal",new U(u,3)),this.setAttribute("uv",new U(p,2));function y(){for(let w=0;w<e;w++)m(w);m(n===!1?e:0),g(),x()}function m(w){l=t.getPointAt(w/e,l);const b=r.normals[w],v=r.binormals[w];for(let S=0;S<=s;S++){const A=S/s*Math.PI*2,_=Math.sin(A),z=-Math.cos(A);a.x=z*b.x+_*v.x,a.y=z*b.y+_*v.y,a.z=z*b.z+_*v.z,a.normalize(),u.push(a.x,a.y,a.z),o.x=l.x+i*a.x,o.y=l.y+i*a.y,o.z=l.z+i*a.z,f.push(o.x,o.y,o.z)}}function x(){for(let w=1;w<=e;w++)for(let b=1;b<=s;b++){const v=(s+1)*(w-1)+(b-1),S=(s+1)*w+(b-1),A=(s+1)*w+b,_=(s+1)*(w-1)+b;d.push(v,S,_),d.push(S,A,_)}}function g(){for(let w=0;w<=e;w++)for(let b=0;b<=s;b++)c.x=w/e,c.y=b/s,p.push(c.x,c.y)}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new vr(new Ts[t.path.type]().fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class zc extends ${constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},t!==null){const e=[],i=new Set,s=new M,n=new M;if(t.index!==null){const r=t.attributes.position,o=t.index;let a=t.groups;a.length===0&&(a=[{start:0,count:o.count,materialIndex:0}]);for(let c=0,l=a.length;c<l;++c){const f=a[c],u=f.start,p=f.count;for(let d=u,y=u+p;d<y;d+=3)for(let m=0;m<3;m++){const x=o.getX(d+m),g=o.getX(d+(m+1)%3);s.fromBufferAttribute(r,x),n.fromBufferAttribute(r,g),ua(s,n,i)===!0&&(e.push(s.x,s.y,s.z),e.push(n.x,n.y,n.z))}}}else{const r=t.attributes.position;for(let o=0,a=r.count/3;o<a;o++)for(let c=0;c<3;c++){const l=3*o+c,f=3*o+(c+1)%3;s.fromBufferAttribute(r,l),n.fromBufferAttribute(r,f),ua(s,n,i)===!0&&(e.push(s.x,s.y,s.z),e.push(n.x,n.y,n.z))}}this.setAttribute("position",new U(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function ua(h,t,e){const i=`${h.x},${h.y},${h.z}-${t.x},${t.y},${t.z}`,s=`${t.x},${t.y},${t.z}-${h.x},${h.y},${h.z}`;return e.has(i)===!0||e.has(s)===!0?!1:(e.add(i),e.add(s),!0)}var fa=Object.freeze({__proto__:null,BoxGeometry:Ln,CapsuleGeometry:rr,CircleGeometry:or,ConeGeometry:ar,CylinderGeometry:Is,DodecahedronGeometry:hr,EdgesGeometry:rc,ExtrudeGeometry:pr,IcosahedronGeometry:dr,LatheGeometry:Cs,OctahedronGeometry:mr,PlaneGeometry:Dn,PolyhedronGeometry:ze,RingGeometry:yr,ShapeGeometry:xr,SphereGeometry:gr,TetrahedronGeometry:wr,TorusGeometry:br,TorusKnotGeometry:Mr,TubeGeometry:vr,WireframeGeometry:zc});class Tc extends yt{static get type(){return"ShadowMaterial"}constructor(t){super(),this.isShadowMaterial=!0,this.color=new q(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class Cc extends So{static get type(){return"RawShaderMaterial"}constructor(t){super(t),this.isRawShaderMaterial=!0}}class pa extends yt{static get type(){return"MeshStandardMaterial"}constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.color=new q(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new q(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new P(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new qt,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Ic extends pa{static get type(){return"MeshPhysicalMaterial"}constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new P(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return rt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new q(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new q(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new q(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class Bc extends yt{static get type(){return"MeshPhongMaterial"}constructor(t){super(),this.isMeshPhongMaterial=!0,this.color=new q(16777215),this.specular=new q(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new q(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new P(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new qt,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Pc extends yt{static get type(){return"MeshToonMaterial"}constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.color=new q(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new q(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new P(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class Fc extends yt{static get type(){return"MeshNormalMaterial"}constructor(t){super(),this.isMeshNormalMaterial=!0,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new P(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class kc extends yt{static get type(){return"MeshLambertMaterial"}constructor(t){super(),this.isMeshLambertMaterial=!0,this.color=new q(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new q(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new P(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new qt,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Ec extends yt{static get type(){return"MeshMatcapMaterial"}constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.color=new q(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new P(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Rc extends Zn{static get type(){return"LineDashedMaterial"}constructor(t){super(),this.isLineDashedMaterial=!0,this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function Ls(h,t,e){return!h||!e&&h.constructor===t?h:typeof t.BYTES_PER_ELEMENT=="number"?new t(h):Array.prototype.slice.call(h)}function Lc(h){return ArrayBuffer.isView(h)&&!(h instanceof DataView)}function Oc(h){function t(s,n){return h[s]-h[n]}const e=h.length,i=new Array(e);for(let s=0;s!==e;++s)i[s]=s;return i.sort(t),i}function da(h,t,e){const i=h.length,s=new h.constructor(i);for(let n=0,r=0;r!==i;++n){const o=e[n]*t;for(let a=0;a!==t;++a)s[r++]=h[o+a]}return s}function ma(h,t,e,i){let s=1,n=h[0];for(;n!==void 0&&n[i]===void 0;)n=h[s++];if(n===void 0)return;let r=n[i];if(r!==void 0)if(Array.isArray(r))do r=n[i],r!==void 0&&(t.push(n.time),e.push.apply(e,r)),n=h[s++];while(n!==void 0);else if(r.toArray!==void 0)do r=n[i],r!==void 0&&(t.push(n.time),r.toArray(e,e.length)),n=h[s++];while(n!==void 0);else do r=n[i],r!==void 0&&(t.push(n.time),e.push(r)),n=h[s++];while(n!==void 0)}class Os{constructor(t,e,i,s){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,s=e[i],n=e[i-1];i:{t:{let r;e:{s:if(!(t<s)){for(let o=i+2;;){if(s===void 0){if(t<n)break s;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===o)break;if(n=s,s=e[++i],t<s)break t}r=e.length;break e}if(!(t>=n)){const o=e[1];t<o&&(i=2,n=o);for(let a=i-2;;){if(n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===a)break;if(s=n,n=e[--i-1],t>=n)break t}r=i,i=0;break e}break i}for(;i<r;){const o=i+r>>>1;t<e[o]?r=o:i=o+1}if(s=e[i],n=e[i-1],n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,n,s)}return this.interpolate_(i,n,t,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,n=t*s;for(let r=0;r!==s;++r)e[r]=i[n+r];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Nc extends Os{constructor(t,e,i,s){super(t,e,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(t,e,i){const s=this.parameterPositions;let n=t-2,r=t+1,o=s[n],a=s[r];if(o===void 0)switch(this.getSettings_().endingStart){case 2401:n=t,o=2*e-i;break;case 2402:n=s.length-2,o=e+s[n]-s[n+1];break;default:n=t,o=i}if(a===void 0)switch(this.getSettings_().endingEnd){case 2401:r=t,a=2*i-e;break;case 2402:r=1,a=i+s[1]-s[0];break;default:r=t-1,a=e}const c=(i-e)*.5,l=this.valueSize;this._weightPrev=c/(e-o),this._weightNext=c/(a-i),this._offsetPrev=n*l,this._offsetNext=r*l}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=t*o,c=a-o,l=this._offsetPrev,f=this._offsetNext,u=this._weightPrev,p=this._weightNext,d=(i-e)/(s-e),y=d*d,m=y*d,x=-u*m+2*u*y-u*d,g=(1+u)*m+(-1.5-2*u)*y+(-.5+u)*d+1,w=(-1-p)*m+(1.5+p)*y+.5*d,b=p*m-p*y;for(let v=0;v!==o;++v)n[v]=x*r[l+v]+g*r[c+v]+w*r[a+v]+b*r[f+v];return n}}class Dc extends Os{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=t*o,c=a-o,l=(i-e)/(s-e),f=1-l;for(let u=0;u!==o;++u)n[u]=r[c+u]*f+r[a+u]*l;return n}}class Vc extends Os{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t){return this.copySampleValue_(t-1)}}class Jt{constructor(t,e,i,s){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Ls(e,this.TimeBufferType),this.values=Ls(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:Ls(t.times,Array),values:Ls(t.values,Array)};const s=t.getInterpolation();s!==t.DefaultInterpolation&&(i.interpolation=s)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new Vc(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Dc(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Nc(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case 2300:e=this.InterpolantFactoryMethodDiscrete;break;case 2301:e=this.InterpolantFactoryMethodLinear;break;case 2302:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]*=t}return this}trim(t,e){const i=this.times,s=i.length;let n=0,r=s-1;for(;n!==s&&i[n]<t;)++n;for(;r!==-1&&i[r]>e;)--r;if(++r,n!==0||r!==s){n>=r&&(r=Math.max(r,1),n=r-1);const o=this.getValueSize();this.times=i.slice(n,r),this.values=this.values.slice(n*o,r*o)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,s=this.values,n=i.length;n===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let r=null;for(let o=0;o!==n;o++){const a=i[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),t=!1;break}if(r!==null&&r>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,r),t=!1;break}r=a}if(s!==void 0&&Lc(s))for(let o=0,a=s.length;o!==a;++o){const c=s[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),i=this.getValueSize(),s=this.getInterpolation()===2302,n=t.length-1;let r=1;for(let o=1;o<n;++o){let a=!1;const c=t[o],l=t[o+1];if(c!==l&&(o!==1||c!==t[0]))if(s)a=!0;else{const f=o*i,u=f-i,p=f+i;for(let d=0;d!==i;++d){const y=e[f+d];if(y!==e[u+d]||y!==e[p+d]){a=!0;break}}}if(a){if(o!==r){t[r]=t[o];const f=o*i,u=r*i;for(let p=0;p!==i;++p)e[u+p]=e[f+p]}++r}}if(n>0){t[r]=t[n];for(let o=n*i,a=r*i,c=0;c!==i;++c)e[a+c]=e[o+c];++r}return r!==t.length?(this.times=t.slice(0,r),this.values=e.slice(0,r*i)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),i=this.constructor,s=new i(this.name,t,e);return s.createInterpolant=this.createInterpolant,s}}Jt.prototype.TimeBufferType=Float32Array,Jt.prototype.ValueBufferType=Float32Array,Jt.prototype.DefaultInterpolation=2301;class ti extends Jt{constructor(t,e,i){super(t,e,i)}}ti.prototype.ValueTypeName="bool",ti.prototype.ValueBufferType=Array,ti.prototype.DefaultInterpolation=2300,ti.prototype.InterpolantFactoryMethodLinear=void 0,ti.prototype.InterpolantFactoryMethodSmooth=void 0;class ya extends Jt{}ya.prototype.ValueTypeName="color";class Ns extends Jt{}Ns.prototype.ValueTypeName="number";class Uc extends Os{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=(i-e)/(s-e);let c=t*o;for(let l=c+o;c!==l;c+=4)Le.slerpFlat(n,0,r,c-o,r,c,a);return n}}class Ds extends Jt{InterpolantFactoryMethodLinear(t){return new Uc(this.times,this.values,this.getValueSize(),t)}}Ds.prototype.ValueTypeName="quaternion",Ds.prototype.InterpolantFactoryMethodSmooth=void 0;class ei extends Jt{constructor(t,e,i){super(t,e,i)}}ei.prototype.ValueTypeName="string",ei.prototype.ValueBufferType=Array,ei.prototype.DefaultInterpolation=2300,ei.prototype.InterpolantFactoryMethodLinear=void 0,ei.prototype.InterpolantFactoryMethodSmooth=void 0;class Vs extends Jt{}Vs.prototype.ValueTypeName="vector";class Wc{constructor(t="",e=-1,i=[],s=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=s,this.uuid=kt(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,s=1/(t.fps||1);for(let r=0,o=i.length;r!==o;++r)e.push(Hc(i[r]).scale(s));const n=new this(t.name,t.duration,e,t.blendMode);return n.uuid=t.uuid,n}static toJSON(t){const e=[],i=t.tracks,s={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let n=0,r=i.length;n!==r;++n)e.push(Jt.toJSON(i[n]));return s}static CreateFromMorphTargetSequence(t,e,i,s){const n=e.length,r=[];for(let o=0;o<n;o++){let a=[],c=[];a.push((o+n-1)%n,o,(o+1)%n),c.push(0,1,0);const l=Oc(a);a=da(a,1,l),c=da(c,1,l),!s&&a[0]===0&&(a.push(n),c.push(c[0])),r.push(new Ns(".morphTargetInfluences["+e[o].name+"]",a,c).scale(1/i))}return new this(t,-1,r)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const s=t;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===e)return i[s];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const s={},n=/^([\w-]*?)([\d]+)$/;for(let o=0,a=t.length;o<a;o++){const c=t[o],l=c.name.match(n);if(l&&l.length>1){const f=l[1];let u=s[f];u||(s[f]=u=[]),u.push(c)}}const r=[];for(const o in s)r.push(this.CreateFromMorphTargetSequence(o,s[o],e,i));return r}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(f,u,p,d,y){if(p.length!==0){const m=[],x=[];ma(p,m,x,d),m.length!==0&&y.push(new f(u,m,x))}},s=[],n=t.name||"default",r=t.fps||30,o=t.blendMode;let a=t.length||-1;const c=t.hierarchy||[];for(let f=0;f<c.length;f++){const u=c[f].keys;if(!(!u||u.length===0))if(u[0].morphTargets){const p={};let d;for(d=0;d<u.length;d++)if(u[d].morphTargets)for(let y=0;y<u[d].morphTargets.length;y++)p[u[d].morphTargets[y]]=-1;for(const y in p){const m=[],x=[];for(let g=0;g!==u[d].morphTargets.length;++g){const w=u[d];m.push(w.time),x.push(w.morphTarget===y?1:0)}s.push(new Ns(".morphTargetInfluence["+y+"]",m,x))}a=p.length*r}else{const p=".bones["+e[f].name+"]";i(Vs,p+".position",u,"pos",s),i(Ds,p+".quaternion",u,"rot",s),i(Vs,p+".scale",u,"scl",s)}}return s.length===0?null:new this(n,a,s,o)}resetDuration(){const t=this.tracks;let e=0;for(let i=0,s=t.length;i!==s;++i){const n=this.tracks[i];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function qc(h){switch(h.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Ns;case"vector":case"vector2":case"vector3":case"vector4":return Vs;case"color":return ya;case"quaternion":return Ds;case"bool":case"boolean":return ti;case"string":return ei}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+h)}function Hc(h){if(h.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=qc(h.type);if(h.times===void 0){const e=[],i=[];ma(h.keys,e,i,"value"),h.times=e,h.values=i}return t.parse!==void 0?t.parse(h):new t(h.name,h.times,h.values,h.interpolation)}const Us={enabled:!1,files:{},add:function(h,t){this.enabled!==!1&&(this.files[h]=t)},get:function(h){if(this.enabled!==!1)return this.files[h]},remove:function(h){delete this.files[h]},clear:function(){this.files={}}};class xa{constructor(t,e,i){const s=this;let n=!1,r=0,o=0,a;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(l){o++,n===!1&&s.onStart!==void 0&&s.onStart(l,r,o),n=!0},this.itemEnd=function(l){r++,s.onProgress!==void 0&&s.onProgress(l,r,o),r===o&&(n=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(l){s.onError!==void 0&&s.onError(l)},this.resolveURL=function(l){return a?a(l):l},this.setURLModifier=function(l){return a=l,this},this.addHandler=function(l,f){return c.push(l,f),this},this.removeHandler=function(l){const f=c.indexOf(l);return f!==-1&&c.splice(f,2),this},this.getHandler=function(l){for(let f=0,u=c.length;f<u;f+=2){const p=c[f],d=c[f+1];if(p.global&&(p.lastIndex=0),p.test(l))return d}return null}}}const Jc=new xa;class ii{constructor(t){this.manager=t!==void 0?t:Jc,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(s,n){i.load(t,s,e,n)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}ii.DEFAULT_MATERIAL_NAME="__DEFAULT";const jt={};class Gc extends Error{constructor(t,e){super(t),this.response=e}}class Ws extends ii{constructor(t){super(t)}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=Us.get(t);if(n!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(n),this.manager.itemEnd(t)},0),n;if(jt[t]!==void 0){jt[t].push({onLoad:e,onProgress:i,onError:s});return}jt[t]=[],jt[t].push({onLoad:e,onProgress:i,onError:s});const r=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,a=this.responseType;fetch(r).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const l=jt[t],f=c.body.getReader(),u=c.headers.get("X-File-Size")||c.headers.get("Content-Length"),p=u?parseInt(u):0,d=p!==0;let y=0;const m=new ReadableStream({start(x){g();function g(){f.read().then(({done:w,value:b})=>{if(w)x.close();else{y+=b.byteLength;const v=new ProgressEvent("progress",{lengthComputable:d,loaded:y,total:p});for(let S=0,A=l.length;S<A;S++){const _=l[S];_.onProgress&&_.onProgress(v)}x.enqueue(b),g()}},w=>{x.error(w)})}}});return new Response(m)}else throw new Gc(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(a){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(l=>new DOMParser().parseFromString(l,o));case"json":return c.json();default:if(o===void 0)return c.text();{const f=/charset="?([^;"\s]*)"?/i.exec(o),u=f&&f[1]?f[1].toLowerCase():void 0,p=new TextDecoder(u);return c.arrayBuffer().then(d=>p.decode(d))}}}).then(c=>{Us.add(t,c);const l=jt[t];delete jt[t];for(let f=0,u=l.length;f<u;f++){const p=l[f];p.onLoad&&p.onLoad(c)}}).catch(c=>{const l=jt[t];if(l===void 0)throw this.manager.itemError(t),c;delete jt[t];for(let f=0,u=l.length;f<u;f++){const p=l[f];p.onError&&p.onError(c)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class ga extends ii{constructor(t){super(t)}load(t,e,i,s){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=this,r=Us.get(t);if(r!==void 0)return n.manager.itemStart(t),setTimeout(function(){e&&e(r),n.manager.itemEnd(t)},0),r;const o=xn("img");function a(){l(),Us.add(t,this),e&&e(this),n.manager.itemEnd(t)}function c(f){l(),s&&s(f),n.manager.itemError(t),n.manager.itemEnd(t)}function l(){o.removeEventListener("load",a,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",a,!1),o.addEventListener("error",c,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),n.manager.itemStart(t),o.src=t,o}}class Ce extends X{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new q(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(e.object.target=this.target.uuid),e}}class $c extends Ce{constructor(t,e,i){super(t,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(X.DEFAULT_UP),this.updateMatrix(),this.groundColor=new q(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const Sr=new N,wa=new M,ba=new M;class Ar{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new P(512,512),this.map=null,this.mapPass=null,this.matrix=new N,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new To,this._frameExtents=new P(1,1),this._viewportCount=1,this._viewports=[new pt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;wa.setFromMatrixPosition(t.matrixWorld),e.position.copy(wa),ba.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(ba),e.updateMatrixWorld(),Sr.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Sr),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(Sr)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.intensity!==1&&(t.intensity=this.intensity),this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Xc extends Ar{constructor(){super(new On(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=dn*2*t.angle*this.focus,s=this.mapSize.width/this.mapSize.height,n=t.distance||e.far;(i!==e.fov||s!==e.aspect||n!==e.far)&&(e.fov=i,e.aspect=s,e.far=n,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class Zc extends Ce{constructor(t,e,i=0,s=Math.PI/3,n=0,r=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(X.DEFAULT_UP),this.updateMatrix(),this.target=new X,this.distance=i,this.angle=s,this.penumbra=n,this.decay=r,this.map=null,this.shadow=new Xc}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Ma=new N,Fi=new M,_r=new M;class Yc extends Ar{constructor(){super(new On(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new P(4,2),this._viewportCount=6,this._viewports=[new pt(2,1,1,1),new pt(0,1,1,1),new pt(3,1,1,1),new pt(1,1,1,1),new pt(3,0,1,1),new pt(1,0,1,1)],this._cubeDirections=[new M(1,0,0),new M(-1,0,0),new M(0,0,1),new M(0,0,-1),new M(0,1,0),new M(0,-1,0)],this._cubeUps=[new M(0,1,0),new M(0,1,0),new M(0,1,0),new M(0,1,0),new M(0,0,1),new M(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,s=this.matrix,n=t.distance||i.far;n!==i.far&&(i.far=n,i.updateProjectionMatrix()),Fi.setFromMatrixPosition(t.matrixWorld),i.position.copy(Fi),_r.copy(i.position),_r.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(_r),i.updateMatrixWorld(),s.makeTranslation(-Fi.x,-Fi.y,-Fi.z),Ma.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ma)}}class Qc extends Ce{constructor(t,e,i=0,s=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new Yc}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class Kc extends Ar{constructor(){super(new Co(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class jc extends Ce{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(X.DEFAULT_UP),this.updateMatrix(),this.target=new X,this.shadow=new Kc}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class tl extends Ce{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class el extends Ce{constructor(t,e,i=10,s=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class il{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new M)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const i=t.x,s=t.y,n=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.282095),e.addScaledVector(r[1],.488603*s),e.addScaledVector(r[2],.488603*n),e.addScaledVector(r[3],.488603*i),e.addScaledVector(r[4],1.092548*(i*s)),e.addScaledVector(r[5],1.092548*(s*n)),e.addScaledVector(r[6],.315392*(3*n*n-1)),e.addScaledVector(r[7],1.092548*(i*n)),e.addScaledVector(r[8],.546274*(i*i-s*s)),e}getIrradianceAt(t,e){const i=t.x,s=t.y,n=t.z,r=this.coefficients;return e.copy(r[0]).multiplyScalar(.886227),e.addScaledVector(r[1],2*.511664*s),e.addScaledVector(r[2],2*.511664*n),e.addScaledVector(r[3],2*.511664*i),e.addScaledVector(r[4],2*.429043*i*s),e.addScaledVector(r[5],2*.429043*s*n),e.addScaledVector(r[6],.743125*n*n-.247708),e.addScaledVector(r[7],2*.429043*i*n),e.addScaledVector(r[8],.429043*(i*i-s*s)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].fromArray(t,e+s*3);return this}toArray(t=[],e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].toArray(t,e+s*3);return t}static getBasisAt(t,e){const i=t.x,s=t.y,n=t.z;e[0]=.282095,e[1]=.488603*s,e[2]=.488603*n,e[3]=.488603*i,e[4]=1.092548*i*s,e[5]=1.092548*s*n,e[6]=.315392*(3*n*n-1),e[7]=1.092548*i*n,e[8]=.546274*(i*i-s*s)}}class sl extends Ce{constructor(t=new il,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class zr extends ii{constructor(t){super(t),this.textures={}}load(t,e,i,s){const n=this,r=new Ws(n.manager);r.setPath(n.path),r.setRequestHeader(n.requestHeader),r.setWithCredentials(n.withCredentials),r.load(t,function(o){try{e(n.parse(JSON.parse(o)))}catch(a){s?s(a):console.error(a),n.manager.itemError(t)}},i,s)}parse(t){const e=this.textures;function i(n){return e[n]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",n),e[n]}const s=this.createMaterialFromType(t.type);if(t.uuid!==void 0&&(s.uuid=t.uuid),t.name!==void 0&&(s.name=t.name),t.color!==void 0&&s.color!==void 0&&s.color.setHex(t.color),t.roughness!==void 0&&(s.roughness=t.roughness),t.metalness!==void 0&&(s.metalness=t.metalness),t.sheen!==void 0&&(s.sheen=t.sheen),t.sheenColor!==void 0&&(s.sheenColor=new q().setHex(t.sheenColor)),t.sheenRoughness!==void 0&&(s.sheenRoughness=t.sheenRoughness),t.emissive!==void 0&&s.emissive!==void 0&&s.emissive.setHex(t.emissive),t.specular!==void 0&&s.specular!==void 0&&s.specular.setHex(t.specular),t.specularIntensity!==void 0&&(s.specularIntensity=t.specularIntensity),t.specularColor!==void 0&&s.specularColor!==void 0&&s.specularColor.setHex(t.specularColor),t.shininess!==void 0&&(s.shininess=t.shininess),t.clearcoat!==void 0&&(s.clearcoat=t.clearcoat),t.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=t.clearcoatRoughness),t.dispersion!==void 0&&(s.dispersion=t.dispersion),t.iridescence!==void 0&&(s.iridescence=t.iridescence),t.iridescenceIOR!==void 0&&(s.iridescenceIOR=t.iridescenceIOR),t.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=t.iridescenceThicknessRange),t.transmission!==void 0&&(s.transmission=t.transmission),t.thickness!==void 0&&(s.thickness=t.thickness),t.attenuationDistance!==void 0&&(s.attenuationDistance=t.attenuationDistance),t.attenuationColor!==void 0&&s.attenuationColor!==void 0&&s.attenuationColor.setHex(t.attenuationColor),t.anisotropy!==void 0&&(s.anisotropy=t.anisotropy),t.anisotropyRotation!==void 0&&(s.anisotropyRotation=t.anisotropyRotation),t.fog!==void 0&&(s.fog=t.fog),t.flatShading!==void 0&&(s.flatShading=t.flatShading),t.blending!==void 0&&(s.blending=t.blending),t.combine!==void 0&&(s.combine=t.combine),t.side!==void 0&&(s.side=t.side),t.shadowSide!==void 0&&(s.shadowSide=t.shadowSide),t.opacity!==void 0&&(s.opacity=t.opacity),t.transparent!==void 0&&(s.transparent=t.transparent),t.alphaTest!==void 0&&(s.alphaTest=t.alphaTest),t.alphaHash!==void 0&&(s.alphaHash=t.alphaHash),t.depthFunc!==void 0&&(s.depthFunc=t.depthFunc),t.depthTest!==void 0&&(s.depthTest=t.depthTest),t.depthWrite!==void 0&&(s.depthWrite=t.depthWrite),t.colorWrite!==void 0&&(s.colorWrite=t.colorWrite),t.blendSrc!==void 0&&(s.blendSrc=t.blendSrc),t.blendDst!==void 0&&(s.blendDst=t.blendDst),t.blendEquation!==void 0&&(s.blendEquation=t.blendEquation),t.blendSrcAlpha!==void 0&&(s.blendSrcAlpha=t.blendSrcAlpha),t.blendDstAlpha!==void 0&&(s.blendDstAlpha=t.blendDstAlpha),t.blendEquationAlpha!==void 0&&(s.blendEquationAlpha=t.blendEquationAlpha),t.blendColor!==void 0&&s.blendColor!==void 0&&s.blendColor.setHex(t.blendColor),t.blendAlpha!==void 0&&(s.blendAlpha=t.blendAlpha),t.stencilWriteMask!==void 0&&(s.stencilWriteMask=t.stencilWriteMask),t.stencilFunc!==void 0&&(s.stencilFunc=t.stencilFunc),t.stencilRef!==void 0&&(s.stencilRef=t.stencilRef),t.stencilFuncMask!==void 0&&(s.stencilFuncMask=t.stencilFuncMask),t.stencilFail!==void 0&&(s.stencilFail=t.stencilFail),t.stencilZFail!==void 0&&(s.stencilZFail=t.stencilZFail),t.stencilZPass!==void 0&&(s.stencilZPass=t.stencilZPass),t.stencilWrite!==void 0&&(s.stencilWrite=t.stencilWrite),t.wireframe!==void 0&&(s.wireframe=t.wireframe),t.wireframeLinewidth!==void 0&&(s.wireframeLinewidth=t.wireframeLinewidth),t.wireframeLinecap!==void 0&&(s.wireframeLinecap=t.wireframeLinecap),t.wireframeLinejoin!==void 0&&(s.wireframeLinejoin=t.wireframeLinejoin),t.rotation!==void 0&&(s.rotation=t.rotation),t.linewidth!==void 0&&(s.linewidth=t.linewidth),t.dashSize!==void 0&&(s.dashSize=t.dashSize),t.gapSize!==void 0&&(s.gapSize=t.gapSize),t.scale!==void 0&&(s.scale=t.scale),t.polygonOffset!==void 0&&(s.polygonOffset=t.polygonOffset),t.polygonOffsetFactor!==void 0&&(s.polygonOffsetFactor=t.polygonOffsetFactor),t.polygonOffsetUnits!==void 0&&(s.polygonOffsetUnits=t.polygonOffsetUnits),t.dithering!==void 0&&(s.dithering=t.dithering),t.alphaToCoverage!==void 0&&(s.alphaToCoverage=t.alphaToCoverage),t.premultipliedAlpha!==void 0&&(s.premultipliedAlpha=t.premultipliedAlpha),t.forceSinglePass!==void 0&&(s.forceSinglePass=t.forceSinglePass),t.visible!==void 0&&(s.visible=t.visible),t.toneMapped!==void 0&&(s.toneMapped=t.toneMapped),t.userData!==void 0&&(s.userData=t.userData),t.vertexColors!==void 0&&(typeof t.vertexColors=="number"?s.vertexColors=t.vertexColors>0:s.vertexColors=t.vertexColors),t.uniforms!==void 0)for(const n in t.uniforms){const r=t.uniforms[n];switch(s.uniforms[n]={},r.type){case"t":s.uniforms[n].value=i(r.value);break;case"c":s.uniforms[n].value=new q().setHex(r.value);break;case"v2":s.uniforms[n].value=new P().fromArray(r.value);break;case"v3":s.uniforms[n].value=new M().fromArray(r.value);break;case"v4":s.uniforms[n].value=new pt().fromArray(r.value);break;case"m3":s.uniforms[n].value=new Ut().fromArray(r.value);break;case"m4":s.uniforms[n].value=new N().fromArray(r.value);break;default:s.uniforms[n].value=r.value}}if(t.defines!==void 0&&(s.defines=t.defines),t.vertexShader!==void 0&&(s.vertexShader=t.vertexShader),t.fragmentShader!==void 0&&(s.fragmentShader=t.fragmentShader),t.glslVersion!==void 0&&(s.glslVersion=t.glslVersion),t.extensions!==void 0)for(const n in t.extensions)s.extensions[n]=t.extensions[n];if(t.lights!==void 0&&(s.lights=t.lights),t.clipping!==void 0&&(s.clipping=t.clipping),t.size!==void 0&&(s.size=t.size),t.sizeAttenuation!==void 0&&(s.sizeAttenuation=t.sizeAttenuation),t.map!==void 0&&(s.map=i(t.map)),t.matcap!==void 0&&(s.matcap=i(t.matcap)),t.alphaMap!==void 0&&(s.alphaMap=i(t.alphaMap)),t.bumpMap!==void 0&&(s.bumpMap=i(t.bumpMap)),t.bumpScale!==void 0&&(s.bumpScale=t.bumpScale),t.normalMap!==void 0&&(s.normalMap=i(t.normalMap)),t.normalMapType!==void 0&&(s.normalMapType=t.normalMapType),t.normalScale!==void 0){let n=t.normalScale;Array.isArray(n)===!1&&(n=[n,n]),s.normalScale=new P().fromArray(n)}return t.displacementMap!==void 0&&(s.displacementMap=i(t.displacementMap)),t.displacementScale!==void 0&&(s.displacementScale=t.displacementScale),t.displacementBias!==void 0&&(s.displacementBias=t.displacementBias),t.roughnessMap!==void 0&&(s.roughnessMap=i(t.roughnessMap)),t.metalnessMap!==void 0&&(s.metalnessMap=i(t.metalnessMap)),t.emissiveMap!==void 0&&(s.emissiveMap=i(t.emissiveMap)),t.emissiveIntensity!==void 0&&(s.emissiveIntensity=t.emissiveIntensity),t.specularMap!==void 0&&(s.specularMap=i(t.specularMap)),t.specularIntensityMap!==void 0&&(s.specularIntensityMap=i(t.specularIntensityMap)),t.specularColorMap!==void 0&&(s.specularColorMap=i(t.specularColorMap)),t.envMap!==void 0&&(s.envMap=i(t.envMap)),t.envMapRotation!==void 0&&s.envMapRotation.fromArray(t.envMapRotation),t.envMapIntensity!==void 0&&(s.envMapIntensity=t.envMapIntensity),t.reflectivity!==void 0&&(s.reflectivity=t.reflectivity),t.refractionRatio!==void 0&&(s.refractionRatio=t.refractionRatio),t.lightMap!==void 0&&(s.lightMap=i(t.lightMap)),t.lightMapIntensity!==void 0&&(s.lightMapIntensity=t.lightMapIntensity),t.aoMap!==void 0&&(s.aoMap=i(t.aoMap)),t.aoMapIntensity!==void 0&&(s.aoMapIntensity=t.aoMapIntensity),t.gradientMap!==void 0&&(s.gradientMap=i(t.gradientMap)),t.clearcoatMap!==void 0&&(s.clearcoatMap=i(t.clearcoatMap)),t.clearcoatRoughnessMap!==void 0&&(s.clearcoatRoughnessMap=i(t.clearcoatRoughnessMap)),t.clearcoatNormalMap!==void 0&&(s.clearcoatNormalMap=i(t.clearcoatNormalMap)),t.clearcoatNormalScale!==void 0&&(s.clearcoatNormalScale=new P().fromArray(t.clearcoatNormalScale)),t.iridescenceMap!==void 0&&(s.iridescenceMap=i(t.iridescenceMap)),t.iridescenceThicknessMap!==void 0&&(s.iridescenceThicknessMap=i(t.iridescenceThicknessMap)),t.transmissionMap!==void 0&&(s.transmissionMap=i(t.transmissionMap)),t.thicknessMap!==void 0&&(s.thicknessMap=i(t.thicknessMap)),t.anisotropyMap!==void 0&&(s.anisotropyMap=i(t.anisotropyMap)),t.sheenColorMap!==void 0&&(s.sheenColorMap=i(t.sheenColorMap)),t.sheenRoughnessMap!==void 0&&(s.sheenRoughnessMap=i(t.sheenRoughnessMap)),s}setTextures(t){return this.textures=t,this}createMaterialFromType(t){return zr.createMaterialFromType(t)}static createMaterialFromType(t){const e={ShadowMaterial:Tc,SpriteMaterial:Po,RawShaderMaterial:Cc,ShaderMaterial:So,PointsMaterial:Yo,MeshPhysicalMaterial:Ic,MeshStandardMaterial:pa,MeshPhongMaterial:Bc,MeshToonMaterial:Pc,MeshNormalMaterial:Fc,MeshLambertMaterial:kc,MeshDepthMaterial:Ch,MeshDistanceMaterial:Ih,MeshBasicMaterial:wo,MeshMatcapMaterial:Ec,LineDashedMaterial:Rc,LineBasicMaterial:Zn,Material:yt};return new e[t]}}class va{static decodeText(t){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let i=0,s=t.length;i<s;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class nl extends ${constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class rl extends ii{constructor(t){super(t)}load(t,e,i,s){const n=this,r=new Ws(n.manager);r.setPath(n.path),r.setRequestHeader(n.requestHeader),r.setWithCredentials(n.withCredentials),r.load(t,function(o){try{e(n.parse(JSON.parse(o)))}catch(a){s?s(a):console.error(a),n.manager.itemError(t)}},i,s)}parse(t){const e={},i={};function s(p,d){if(e[d]!==void 0)return e[d];const m=p.interleavedBuffers[d],x=n(p,m.buffer),g=ke(m.type,x),w=new Bo(g,m.stride);return w.uuid=m.uuid,e[d]=w,w}function n(p,d){if(i[d]!==void 0)return i[d];const m=p.arrayBuffers[d],x=new Uint32Array(m).buffer;return i[d]=x,x}const r=t.isInstancedBufferGeometry?new nl:new $,o=t.data.index;if(o!==void 0){const p=ke(o.type,o.array);r.setIndex(new xt(p,1))}const a=t.data.attributes;for(const p in a){const d=a[p];let y;if(d.isInterleavedBufferAttribute){const m=s(t.data,d.data);y=new $e(m,d.itemSize,d.offset,d.normalized)}else{const m=ke(d.type,d.array),x=d.isInstancedBufferAttribute?Mi:xt;y=new x(m,d.itemSize,d.normalized)}d.name!==void 0&&(y.name=d.name),d.usage!==void 0&&y.setUsage(d.usage),r.setAttribute(p,y)}const c=t.data.morphAttributes;if(c)for(const p in c){const d=c[p],y=[];for(let m=0,x=d.length;m<x;m++){const g=d[m];let w;if(g.isInterleavedBufferAttribute){const b=s(t.data,g.data);w=new $e(b,g.itemSize,g.offset,g.normalized)}else{const b=ke(g.type,g.array);w=new xt(b,g.itemSize,g.normalized)}g.name!==void 0&&(w.name=g.name),y.push(w)}r.morphAttributes[p]=y}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const f=t.data.groups||t.data.drawcalls||t.data.offsets;if(f!==void 0)for(let p=0,d=f.length;p!==d;++p){const y=f[p];r.addGroup(y.start,y.count,y.materialIndex)}const u=t.data.boundingSphere;if(u!==void 0){const p=new M;u.center!==void 0&&p.fromArray(u.center),r.boundingSphere=new ht(p,u.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}}class ol extends ii{constructor(t){super(t)}load(t,e,i,s){const n=this,r=this.path===""?va.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||r;const o=new Ws(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(a){let c=null;try{c=JSON.parse(a)}catch(f){s!==void 0&&s(f),console.error("THREE:ObjectLoader: Can't parse "+t+".",f.message);return}const l=c.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry"){s!==void 0&&s(new Error("THREE.ObjectLoader: Can't load "+t)),console.error("THREE.ObjectLoader: Can't load "+t);return}n.parse(c,e)},i,s)}async loadAsync(t,e){const i=this,s=this.path===""?va.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||s;const n=new Ws(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials);const r=await n.loadAsync(t,e),o=JSON.parse(r),a=o.metadata;if(a===void 0||a.type===void 0||a.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+t);return await i.parseAsync(o)}parse(t,e){const i=this.parseAnimations(t.animations),s=this.parseShapes(t.shapes),n=this.parseGeometries(t.geometries,s),r=this.parseImages(t.images,function(){e!==void 0&&e(c)}),o=this.parseTextures(t.textures,r),a=this.parseMaterials(t.materials,o),c=this.parseObject(t.object,n,a,o,i),l=this.parseSkeletons(t.skeletons,c);if(this.bindSkeletons(c,l),this.bindLightTargets(c),e!==void 0){let f=!1;for(const u in r)if(r[u].data instanceof HTMLImageElement){f=!0;break}f===!1&&e(c)}return c}async parseAsync(t){const e=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),s=this.parseGeometries(t.geometries,i),n=await this.parseImagesAsync(t.images),r=this.parseTextures(t.textures,n),o=this.parseMaterials(t.materials,r),a=this.parseObject(t.object,s,o,r,e),c=this.parseSkeletons(t.skeletons,a);return this.bindSkeletons(a,c),this.bindLightTargets(a),a}parseShapes(t){const e={};if(t!==void 0)for(let i=0,s=t.length;i<s;i++){const n=new lr().fromJSON(t[i]);e[n.uuid]=n}return e}parseSkeletons(t,e){const i={},s={};if(e.traverse(function(n){n.isBone&&(s[n.uuid]=n)}),t!==void 0)for(let n=0,r=t.length;n<r;n++){const o=new Jn().fromJSON(t[n],s);i[o.uuid]=o}return i}parseGeometries(t,e){const i={};if(t!==void 0){const s=new rl;for(let n=0,r=t.length;n<r;n++){let o;const a=t[n];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":o=s.parse(a);break;default:a.type in fa?o=fa[a.type].fromJSON(a,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}o.uuid=a.uuid,a.name!==void 0&&(o.name=a.name),a.userData!==void 0&&(o.userData=a.userData),i[a.uuid]=o}}return i}parseMaterials(t,e){const i={},s={};if(t!==void 0){const n=new zr;n.setTextures(e);for(let r=0,o=t.length;r<o;r++){const a=t[r];i[a.uuid]===void 0&&(i[a.uuid]=n.parse(a)),s[a.uuid]=i[a.uuid]}}return s}parseAnimations(t){const e={};if(t!==void 0)for(let i=0;i<t.length;i++){const s=t[i],n=Wc.parse(s);e[n.uuid]=n}return e}parseImages(t,e){const i=this,s={};let n;function r(a){return i.manager.itemStart(a),n.load(a,function(){i.manager.itemEnd(a)},void 0,function(){i.manager.itemError(a),i.manager.itemEnd(a)})}function o(a){if(typeof a=="string"){const c=a,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:i.resourcePath+c;return r(l)}else return a.data?{data:ke(a.type,a.data),width:a.width,height:a.height}:null}if(t!==void 0&&t.length>0){const a=new xa(e);n=new ga(a),n.setCrossOrigin(this.crossOrigin);for(let c=0,l=t.length;c<l;c++){const f=t[c],u=f.url;if(Array.isArray(u)){const p=[];for(let d=0,y=u.length;d<y;d++){const m=u[d],x=o(m);x!==null&&(x instanceof HTMLImageElement?p.push(x):p.push(new de(x.data,x.width,x.height)))}s[f.uuid]=new pi(p)}else{const p=o(f.url);s[f.uuid]=new pi(p)}}}return s}async parseImagesAsync(t){const e=this,i={};let s;async function n(r){if(typeof r=="string"){const o=r,a=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o)?o:e.resourcePath+o;return await s.loadAsync(a)}else return r.data?{data:ke(r.type,r.data),width:r.width,height:r.height}:null}if(t!==void 0&&t.length>0){s=new ga(this.manager),s.setCrossOrigin(this.crossOrigin);for(let r=0,o=t.length;r<o;r++){const a=t[r],c=a.url;if(Array.isArray(c)){const l=[];for(let f=0,u=c.length;f<u;f++){const p=c[f],d=await n(p);d!==null&&(d instanceof HTMLImageElement?l.push(d):l.push(new de(d.data,d.width,d.height)))}i[a.uuid]=new pi(l)}else{const l=await n(a.url);i[a.uuid]=new pi(l)}}}return i}parseTextures(t,e){function i(n,r){return typeof n=="number"?n:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",n),r[n])}const s={};if(t!==void 0)for(let n=0,r=t.length;n<r;n++){const o=t[n];o.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',o.uuid),e[o.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",o.image);const a=e[o.image],c=a.data;let l;Array.isArray(c)?(l=new _h,c.length===6&&(l.needsUpdate=!0)):(c&&c.data?l=new de:l=new Wt,c&&(l.needsUpdate=!0)),l.source=a,l.uuid=o.uuid,o.name!==void 0&&(l.name=o.name),o.mapping!==void 0&&(l.mapping=i(o.mapping,al)),o.channel!==void 0&&(l.channel=o.channel),o.offset!==void 0&&l.offset.fromArray(o.offset),o.repeat!==void 0&&l.repeat.fromArray(o.repeat),o.center!==void 0&&l.center.fromArray(o.center),o.rotation!==void 0&&(l.rotation=o.rotation),o.wrap!==void 0&&(l.wrapS=i(o.wrap[0],Sa),l.wrapT=i(o.wrap[1],Sa)),o.format!==void 0&&(l.format=o.format),o.internalFormat!==void 0&&(l.internalFormat=o.internalFormat),o.type!==void 0&&(l.type=o.type),o.colorSpace!==void 0&&(l.colorSpace=o.colorSpace),o.minFilter!==void 0&&(l.minFilter=i(o.minFilter,Aa)),o.magFilter!==void 0&&(l.magFilter=i(o.magFilter,Aa)),o.anisotropy!==void 0&&(l.anisotropy=o.anisotropy),o.flipY!==void 0&&(l.flipY=o.flipY),o.generateMipmaps!==void 0&&(l.generateMipmaps=o.generateMipmaps),o.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=o.premultiplyAlpha),o.unpackAlignment!==void 0&&(l.unpackAlignment=o.unpackAlignment),o.compareFunction!==void 0&&(l.compareFunction=o.compareFunction),o.userData!==void 0&&(l.userData=o.userData),s[o.uuid]=l}return s}parseObject(t,e,i,s,n){let r;function o(u){return e[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),e[u]}function a(u){if(u!==void 0){if(Array.isArray(u)){const p=[];for(let d=0,y=u.length;d<y;d++){const m=u[d];i[m]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",m),p.push(i[m])}return p}return i[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),i[u]}}function c(u){return s[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",u),s[u]}let l,f;switch(t.type){case"Scene":r=new Io,t.background!==void 0&&(Number.isInteger(t.background)?r.background=new q(t.background):r.background=c(t.background)),t.environment!==void 0&&(r.environment=c(t.environment)),t.fog!==void 0&&(t.fog.type==="Fog"?r.fog=new Un(t.fog.color,t.fog.near,t.fog.far):t.fog.type==="FogExp2"&&(r.fog=new Vn(t.fog.color,t.fog.density)),t.fog.name!==""&&(r.fog.name=t.fog.name)),t.backgroundBlurriness!==void 0&&(r.backgroundBlurriness=t.backgroundBlurriness),t.backgroundIntensity!==void 0&&(r.backgroundIntensity=t.backgroundIntensity),t.backgroundRotation!==void 0&&r.backgroundRotation.fromArray(t.backgroundRotation),t.environmentIntensity!==void 0&&(r.environmentIntensity=t.environmentIntensity),t.environmentRotation!==void 0&&r.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":r=new On(t.fov,t.aspect,t.near,t.far),t.focus!==void 0&&(r.focus=t.focus),t.zoom!==void 0&&(r.zoom=t.zoom),t.filmGauge!==void 0&&(r.filmGauge=t.filmGauge),t.filmOffset!==void 0&&(r.filmOffset=t.filmOffset),t.view!==void 0&&(r.view=Object.assign({},t.view));break;case"OrthographicCamera":r=new Co(t.left,t.right,t.top,t.bottom,t.near,t.far),t.zoom!==void 0&&(r.zoom=t.zoom),t.view!==void 0&&(r.view=Object.assign({},t.view));break;case"AmbientLight":r=new tl(t.color,t.intensity);break;case"DirectionalLight":r=new jc(t.color,t.intensity),r.target=t.target||"";break;case"PointLight":r=new Qc(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":r=new el(t.color,t.intensity,t.width,t.height);break;case"SpotLight":r=new Zc(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay),r.target=t.target||"";break;case"HemisphereLight":r=new $c(t.color,t.groundColor,t.intensity);break;case"LightProbe":r=new sl().fromJSON(t);break;case"SkinnedMesh":l=o(t.geometry),f=a(t.material),r=new Eh(l,f),t.bindMode!==void 0&&(r.bindMode=t.bindMode),t.bindMatrix!==void 0&&r.bindMatrix.fromArray(t.bindMatrix),t.skeleton!==void 0&&(r.skeleton=t.skeleton);break;case"Mesh":l=o(t.geometry),f=a(t.material),r=new Kt(l,f);break;case"InstancedMesh":l=o(t.geometry),f=a(t.material);const u=t.count,p=t.instanceMatrix,d=t.instanceColor;r=new Oh(l,f,u),r.instanceMatrix=new Mi(new Float32Array(p.array),16),d!==void 0&&(r.instanceColor=new Mi(new Float32Array(d.array),d.itemSize));break;case"BatchedMesh":l=o(t.geometry),f=a(t.material),r=new _i(t.maxInstanceCount,t.maxVertexCount,t.maxIndexCount,f),r.geometry=l,r.perObjectFrustumCulled=t.perObjectFrustumCulled,r.sortObjects=t.sortObjects,r._drawRanges=t.drawRanges,r._reservedRanges=t.reservedRanges,r._visibility=t.visibility,r._active=t.active,r._bounds=t.bounds.map(y=>{const m=new Y;m.min.fromArray(y.boxMin),m.max.fromArray(y.boxMax);const x=new ht;return x.radius=y.sphereRadius,x.center.fromArray(y.sphereCenter),{boxInitialized:y.boxInitialized,box:m,sphereInitialized:y.sphereInitialized,sphere:x}}),r._maxInstanceCount=t.maxInstanceCount,r._maxVertexCount=t.maxVertexCount,r._maxIndexCount=t.maxIndexCount,r._geometryInitialized=t.geometryInitialized,r._geometryCount=t.geometryCount,r._matricesTexture=c(t.matricesTexture.uuid),t.colorsTexture!==void 0&&(r._colorsTexture=c(t.colorsTexture.uuid));break;case"LOD":r=new Fh;break;case"Line":r=new Qn(o(t.geometry),a(t.material));break;case"LineLoop":r=new Jh(o(t.geometry),a(t.material));break;case"LineSegments":r=new Hh(o(t.geometry),a(t.material));break;case"PointCloud":case"Points":r=new Gh(o(t.geometry),a(t.material));break;case"Sprite":r=new Ph(a(t.material));break;case"Group":r=new Bh;break;case"Bone":r=new Uo;break;default:r=new X}if(r.uuid=t.uuid,t.name!==void 0&&(r.name=t.name),t.matrix!==void 0?(r.matrix.fromArray(t.matrix),t.matrixAutoUpdate!==void 0&&(r.matrixAutoUpdate=t.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(t.position!==void 0&&r.position.fromArray(t.position),t.rotation!==void 0&&r.rotation.fromArray(t.rotation),t.quaternion!==void 0&&r.quaternion.fromArray(t.quaternion),t.scale!==void 0&&r.scale.fromArray(t.scale)),t.up!==void 0&&r.up.fromArray(t.up),t.castShadow!==void 0&&(r.castShadow=t.castShadow),t.receiveShadow!==void 0&&(r.receiveShadow=t.receiveShadow),t.shadow&&(t.shadow.intensity!==void 0&&(r.shadow.intensity=t.shadow.intensity),t.shadow.bias!==void 0&&(r.shadow.bias=t.shadow.bias),t.shadow.normalBias!==void 0&&(r.shadow.normalBias=t.shadow.normalBias),t.shadow.radius!==void 0&&(r.shadow.radius=t.shadow.radius),t.shadow.mapSize!==void 0&&r.shadow.mapSize.fromArray(t.shadow.mapSize),t.shadow.camera!==void 0&&(r.shadow.camera=this.parseObject(t.shadow.camera))),t.visible!==void 0&&(r.visible=t.visible),t.frustumCulled!==void 0&&(r.frustumCulled=t.frustumCulled),t.renderOrder!==void 0&&(r.renderOrder=t.renderOrder),t.userData!==void 0&&(r.userData=t.userData),t.layers!==void 0&&(r.layers.mask=t.layers),t.children!==void 0){const u=t.children;for(let p=0;p<u.length;p++)r.add(this.parseObject(u[p],e,i,s,n))}if(t.animations!==void 0){const u=t.animations;for(let p=0;p<u.length;p++){const d=u[p];r.animations.push(n[d])}}if(t.type==="LOD"){t.autoUpdate!==void 0&&(r.autoUpdate=t.autoUpdate);const u=t.levels;for(let p=0;p<u.length;p++){const d=u[p],y=r.getObjectByProperty("uuid",d.object);y!==void 0&&r.addLevel(y,d.distance,d.hysteresis)}}return r}bindSkeletons(t,e){Object.keys(e).length!==0&&t.traverse(function(i){if(i.isSkinnedMesh===!0&&i.skeleton!==void 0){const s=e[i.skeleton];s===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",i.skeleton):i.bind(s,i.bindMatrix)}})}bindLightTargets(t){t.traverse(function(e){if(e.isDirectionalLight||e.isSpotLight){const i=e.target,s=t.getObjectByProperty("uuid",i);s!==void 0?e.target=s:e.target=new X}})}}const al={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,CubeUVReflectionMapping:306},Sa={RepeatWrapping:1e3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},Aa={NearestFilter:1003,NearestMipmapNearestFilter:1004,NearestMipmapLinearFilter:1005,LinearFilter:1006,LinearMipmapNearestFilter:1007,LinearMipmapLinearFilter:1008},_a=new N;class hl{constructor(t,e,i=0,s=1/0){this.ray=new Ve(t,e),this.near=i,this.far=s,this.camera=null,this.layers=new lo,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}setFromXRController(t){return _a.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(_a),this}intersectObject(t,e=!0,i=[]){return Tr(t,this,i,e),i.sort(za),i}intersectObjects(t,e=!0,i=[]){for(let s=0,n=t.length;s<n;s++)Tr(t[s],this,i,e);return i.sort(za),i}}function za(h,t){return h.distance-t.distance}function Tr(h,t,e,i){let s=!0;if(h.layers.test(t.layers)&&h.raycast(t,e)===!1&&(s=!1),s===!0&&i===!0){const n=h.children;for(let r=0,o=n.length;r<o;r++)Tr(n[r],t,e,!0)}}const Ta=new M,qs=new M;class te{constructor(t=new M,e=new M){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){Ta.subVectors(t,this.start),qs.subVectors(this.end,this.start);const i=qs.dot(qs);let n=qs.dot(Ta)/i;return e&&(n=rt(n,0,1)),n}closestPointToPoint(t,e,i){const s=this.closestPointToPointParameter(t,e);return this.delta(i).multiplyScalar(s).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Gi}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Gi);const Ca=0,cl=1,ll=2,Ia=2,Cr=1.25,Ba=1,ki=6*4+4+4,Hs=65535,ul=Math.pow(2,-24),Ir=Symbol("SKIP_GENERATION");function fl(h){return h.index?h.index.count:h.attributes.position.count}function si(h){return fl(h)/3}function pl(h,t=ArrayBuffer){return h>65535?new Uint32Array(new t(4*h)):new Uint16Array(new t(2*h))}function dl(h,t){if(!h.index){const e=h.attributes.position.count,i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=pl(e,i);h.setIndex(new xt(s,1));for(let n=0;n<e;n++)s[n]=n}}function Pa(h,t){const e=si(h),i=t||h.drawRange,s=i.start/3,n=(i.start+i.count)/3,r=Math.max(0,s),o=Math.min(e,n)-r;return[{offset:Math.floor(r),count:Math.floor(o)}]}function Fa(h,t){if(!h.groups||!h.groups.length)return Pa(h,t);const e=[],i=new Set,s=t||h.drawRange,n=s.start/3,r=(s.start+s.count)/3;for(const a of h.groups){const c=a.start/3,l=(a.start+a.count)/3;i.add(Math.max(n,c)),i.add(Math.min(r,l))}const o=Array.from(i.values()).sort((a,c)=>a-c);for(let a=0;a<o.length-1;a++){const c=o[a],l=o[a+1];e.push({offset:Math.floor(c),count:Math.floor(l-c)})}return e}function ml(h,t){const e=si(h),i=Fa(h,t).sort((r,o)=>r.offset-o.offset),s=i[i.length-1];s.count=Math.min(e-s.offset,s.count);let n=0;return i.forEach(({count:r})=>n+=r),e!==n}function Br(h,t,e,i,s){let n=1/0,r=1/0,o=1/0,a=-1/0,c=-1/0,l=-1/0,f=1/0,u=1/0,p=1/0,d=-1/0,y=-1/0,m=-1/0;for(let x=t*6,g=(t+e)*6;x<g;x+=6){const w=h[x+0],b=h[x+1],v=w-b,S=w+b;v<n&&(n=v),S>a&&(a=S),w<f&&(f=w),w>d&&(d=w);const A=h[x+2],_=h[x+3],z=A-_,T=A+_;z<r&&(r=z),T>c&&(c=T),A<u&&(u=A),A>y&&(y=A);const I=h[x+4],C=h[x+5],B=I-C,F=I+C;B<o&&(o=B),F>l&&(l=F),I<p&&(p=I),I>m&&(m=I)}i[0]=n,i[1]=r,i[2]=o,i[3]=a,i[4]=c,i[5]=l,s[0]=f,s[1]=u,s[2]=p,s[3]=d,s[4]=y,s[5]=m}function yl(h,t=null,e=null,i=null){const s=h.attributes.position,n=h.index?h.index.array:null,r=si(h),o=s.normalized;let a;t===null?(a=new Float32Array(r*6),e=0,i=r):(a=t,e=e||0,i=i||r);const c=s.array,l=s.offset||0;let f=3;s.isInterleavedBufferAttribute&&(f=s.data.stride);const u=["getX","getY","getZ"];for(let p=e;p<e+i;p++){const d=p*3,y=p*6;let m=d+0,x=d+1,g=d+2;n&&(m=n[m],x=n[x],g=n[g]),o||(m=m*f+l,x=x*f+l,g=g*f+l);for(let w=0;w<3;w++){let b,v,S;o?(b=s[u[w]](m),v=s[u[w]](x),S=s[u[w]](g)):(b=c[m+w],v=c[x+w],S=c[g+w]);let A=b;v<A&&(A=v),S<A&&(A=S);let _=b;v>_&&(_=v),S>_&&(_=S);const z=(_-A)/2,T=w*2;a[y+T+0]=A+z,a[y+T+1]=z+(Math.abs(A)+z)*ul}}return a}function K(h,t,e){return e.min.x=t[h],e.min.y=t[h+1],e.min.z=t[h+2],e.max.x=t[h+3],e.max.y=t[h+4],e.max.z=t[h+5],e}function ka(h){let t=-1,e=-1/0;for(let i=0;i<3;i++){const s=h[i+3]-h[i];s>e&&(e=s,t=i)}return t}function Ea(h,t){t.set(h)}function Ra(h,t,e){let i,s;for(let n=0;n<3;n++){const r=n+3;i=h[n],s=t[n],e[n]=i<s?i:s,i=h[r],s=t[r],e[r]=i>s?i:s}}function Js(h,t,e){for(let i=0;i<3;i++){const s=t[h+2*i],n=t[h+2*i+1],r=s-n,o=s+n;r<e[i]&&(e[i]=r),o>e[i+3]&&(e[i+3]=o)}}function Ei(h){const t=h[3]-h[0],e=h[4]-h[1],i=h[5]-h[2];return 2*(t*e+e*i+i*t)}const ee=32,xl=(h,t)=>h.candidate-t.candidate,ye=new Array(ee).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Gs=new Float32Array(6);function gl(h,t,e,i,s,n){let r=-1,o=0;if(n===Ca)r=ka(t),r!==-1&&(o=(t[r]+t[r+3])/2);else if(n===cl)r=ka(h),r!==-1&&(o=wl(e,i,s,r));else if(n===ll){const a=Ei(h);let c=Cr*s;const l=i*6,f=(i+s)*6;for(let u=0;u<3;u++){const p=t[u],m=(t[u+3]-p)/ee;if(s<ee/4){const x=[...ye];x.length=s;let g=0;for(let b=l;b<f;b+=6,g++){const v=x[g];v.candidate=e[b+2*u],v.count=0;const{bounds:S,leftCacheBounds:A,rightCacheBounds:_}=v;for(let z=0;z<3;z++)_[z]=1/0,_[z+3]=-1/0,A[z]=1/0,A[z+3]=-1/0,S[z]=1/0,S[z+3]=-1/0;Js(b,e,S)}x.sort(xl);let w=s;for(let b=0;b<w;b++){const v=x[b];for(;b+1<w&&x[b+1].candidate===v.candidate;)x.splice(b+1,1),w--}for(let b=l;b<f;b+=6){const v=e[b+2*u];for(let S=0;S<w;S++){const A=x[S];v>=A.candidate?Js(b,e,A.rightCacheBounds):(Js(b,e,A.leftCacheBounds),A.count++)}}for(let b=0;b<w;b++){const v=x[b],S=v.count,A=s-v.count,_=v.leftCacheBounds,z=v.rightCacheBounds;let T=0;S!==0&&(T=Ei(_)/a);let I=0;A!==0&&(I=Ei(z)/a);const C=Ba+Cr*(T*S+I*A);C<c&&(r=u,c=C,o=v.candidate)}}else{for(let w=0;w<ee;w++){const b=ye[w];b.count=0,b.candidate=p+m+w*m;const v=b.bounds;for(let S=0;S<3;S++)v[S]=1/0,v[S+3]=-1/0}for(let w=l;w<f;w+=6){let S=~~((e[w+2*u]-p)/m);S>=ee&&(S=ee-1);const A=ye[S];A.count++,Js(w,e,A.bounds)}const x=ye[ee-1];Ea(x.bounds,x.rightCacheBounds);for(let w=ee-2;w>=0;w--){const b=ye[w],v=ye[w+1];Ra(b.bounds,v.rightCacheBounds,b.rightCacheBounds)}let g=0;for(let w=0;w<ee-1;w++){const b=ye[w],v=b.count,S=b.bounds,_=ye[w+1].rightCacheBounds;v!==0&&(g===0?Ea(S,Gs):Ra(S,Gs,Gs)),g+=v;let z=0,T=0;g!==0&&(z=Ei(Gs)/a);const I=s-g;I!==0&&(T=Ei(_)/a);const C=Ba+Cr*(z*g+T*I);C<c&&(r=u,c=C,o=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:r,pos:o}}function wl(h,t,e,i){let s=0;for(let n=t,r=t+e;n<r;n++)s+=h[n*6+i*2];return s/e}class Pr{constructor(){this.boundingData=new Float32Array(6)}}function bl(h,t,e,i,s,n){let r=i,o=i+s-1;const a=n.pos,c=n.axis*2;for(;;){for(;r<=o&&e[r*6+c]<a;)r++;for(;r<=o&&e[o*6+c]>=a;)o--;if(r<o){for(let l=0;l<3;l++){let f=t[r*3+l];t[r*3+l]=t[o*3+l],t[o*3+l]=f}for(let l=0;l<6;l++){let f=e[r*6+l];e[r*6+l]=e[o*6+l],e[o*6+l]=f}r++,o--}else return r}}function Ml(h,t,e,i,s,n){let r=i,o=i+s-1;const a=n.pos,c=n.axis*2;for(;;){for(;r<=o&&e[r*6+c]<a;)r++;for(;r<=o&&e[o*6+c]>=a;)o--;if(r<o){let l=h[r];h[r]=h[o],h[o]=l;for(let f=0;f<6;f++){let u=e[r*6+f];e[r*6+f]=e[o*6+f],e[o*6+f]=u}r++,o--}else return r}}function vt(h,t){return t[h+15]===65535}function zt(h,t){return t[h+6]}function Ct(h,t){return t[h+14]}function It(h){return h+8}function Bt(h,t){return t[h+6]}function La(h,t){return t[h+7]}function yf(h){return h}let Oa,Ri,$s,Na;const vl=Math.pow(2,32);function Fr(h){return"count"in h?1:1+Fr(h.left)+Fr(h.right)}function Sl(h,t,e){return Oa=new Float32Array(e),Ri=new Uint32Array(e),$s=new Uint16Array(e),Na=new Uint8Array(e),kr(h,t)}function kr(h,t){const e=h/4,i=h/2,s="count"in t,n=t.boundingData;for(let r=0;r<6;r++)Oa[e+r]=n[r];if(s)if(t.buffer){const r=t.buffer;Na.set(new Uint8Array(r),h);for(let o=h,a=h+r.byteLength;o<a;o+=ki){const c=o/2;vt(c,$s)||(Ri[o/4+6]+=e)}return h+r.byteLength}else{const r=t.offset,o=t.count;return Ri[e+6]=r,$s[i+14]=o,$s[i+15]=Hs,h+ki}else{const r=t.left,o=t.right,a=t.splitAxis;let c;if(c=kr(h+ki,r),c/4>vl)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ri[e+6]=c/4,c=kr(c,o),Ri[e+7]=a,c}}function Al(h,t){const e=(h.index?h.index.count:h.attributes.position.count)/3,i=e>2**16,s=i?4:2,n=t?new SharedArrayBuffer(e*s):new ArrayBuffer(e*s),r=i?new Uint32Array(n):new Uint16Array(n);for(let o=0,a=r.length;o<a;o++)r[o]=o;return r}function _l(h,t,e,i,s){const{maxDepth:n,verbose:r,maxLeafTris:o,strategy:a,onProgress:c,indirect:l}=s,f=h._indirectBuffer,u=h.geometry,p=u.index?u.index.array:null,d=l?Ml:bl,y=si(u),m=new Float32Array(6);let x=!1;const g=new Pr;return Br(t,e,i,g.boundingData,m),b(g,e,i,m),g;function w(v){c&&c(v/y)}function b(v,S,A,_=null,z=0){if(!x&&z>=n&&(x=!0,r&&(console.warn(`MeshBVH: Max depth of ${n} reached when generating BVH. Consider increasing maxDepth.`),console.warn(u))),A<=o||z>=n)return w(S+A),v.offset=S,v.count=A,v;const T=gl(v.boundingData,_,t,S,A,a);if(T.axis===-1)return w(S+A),v.offset=S,v.count=A,v;const I=d(f,p,t,S,A,T);if(I===S||I===S+A)w(S+A),v.offset=S,v.count=A;else{v.splitAxis=T.axis;const C=new Pr,B=S,F=I-S;v.left=C,Br(t,B,F,C.boundingData,m),b(C,B,F,m,z+1);const O=new Pr,D=I,et=A-F;v.right=O,Br(t,D,et,O.boundingData,m),b(O,D,et,m,z+1)}return v}}function zl(h,t){const e=h.geometry;t.indirect&&(h._indirectBuffer=Al(e,t.useSharedArrayBuffer),ml(e,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),h._indirectBuffer||dl(e,t);const i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=yl(e),n=t.indirect?Pa(e,t.range):Fa(e,t.range);h._roots=n.map(r=>{const o=_l(h,s,r.offset,r.count,t),a=Fr(o),c=new i(ki*a);return Sl(0,o,c),c})}class ie{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let i=1/0,s=-1/0;for(let n=0,r=t.length;n<r;n++){const a=t[n][e];i=a<i?a:i,s=a>s?a:s}this.min=i,this.max=s}setFromPoints(t,e){let i=1/0,s=-1/0;for(let n=0,r=e.length;n<r;n++){const o=e[n],a=t.dot(o);i=a<i?a:i,s=a>s?a:s}this.min=i,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}ie.prototype.setFromBox=function(){const h=new M;return function(e,i){const s=i.min,n=i.max;let r=1/0,o=-1/0;for(let a=0;a<=1;a++)for(let c=0;c<=1;c++)for(let l=0;l<=1;l++){h.x=s.x*a+n.x*(1-a),h.y=s.y*c+n.y*(1-c),h.z=s.z*l+n.z*(1-l);const f=e.dot(h);r=Math.min(f,r),o=Math.max(f,o)}this.min=r,this.max=o}}();const Tl=function(){const h=new M,t=new M,e=new M;return function(s,n,r){const o=s.start,a=h,c=n.start,l=t;e.subVectors(o,c),h.subVectors(s.end,s.start),t.subVectors(n.end,n.start);const f=e.dot(l),u=l.dot(a),p=l.dot(l),d=e.dot(a),m=a.dot(a)*p-u*u;let x,g;m!==0?x=(f*u-d*p)/m:x=0,g=(f+x*u)/p,r.x=x,r.y=g}}(),Er=function(){const h=new P,t=new M,e=new M;return function(s,n,r,o){Tl(s,n,h);let a=h.x,c=h.y;if(a>=0&&a<=1&&c>=0&&c<=1){s.at(a,r),n.at(c,o);return}else if(a>=0&&a<=1){c<0?n.at(0,o):n.at(1,o),s.closestPointToPoint(o,!0,r);return}else if(c>=0&&c<=1){a<0?s.at(0,r):s.at(1,r),n.closestPointToPoint(r,!0,o);return}else{let l;a<0?l=s.start:l=s.end;let f;c<0?f=n.start:f=n.end;const u=t,p=e;if(s.closestPointToPoint(f,!0,t),n.closestPointToPoint(l,!0,e),u.distanceToSquared(f)<=p.distanceToSquared(l)){r.copy(u),o.copy(f);return}else{r.copy(l),o.copy(p);return}}}}(),Cl=function(){const h=new M,t=new M,e=new pe,i=new te;return function(n,r){const{radius:o,center:a}=n,{a:c,b:l,c:f}=r;if(i.start=c,i.end=l,i.closestPointToPoint(a,!0,h).distanceTo(a)<=o||(i.start=c,i.end=f,i.closestPointToPoint(a,!0,h).distanceTo(a)<=o)||(i.start=l,i.end=f,i.closestPointToPoint(a,!0,h).distanceTo(a)<=o))return!0;const y=r.getPlane(e);if(Math.abs(y.distanceToPoint(a))<=o){const x=y.projectPoint(a,t);if(r.containsPoint(x))return!0}return!1}}(),Il=1e-15;function Rr(h){return Math.abs(h)<Il}class Ot extends ot{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new M),this.satBounds=new Array(4).fill().map(()=>new ie),this.points=[this.a,this.b,this.c],this.sphere=new ht,this.plane=new pe,this.needsUpdate=!0}intersectsSphere(t){return Cl(t,this)}update(){const t=this.a,e=this.b,i=this.c,s=this.points,n=this.satAxes,r=this.satBounds,o=n[0],a=r[0];this.getNormal(o),a.setFromPoints(o,s);const c=n[1],l=r[1];c.subVectors(t,e),l.setFromPoints(c,s);const f=n[2],u=r[2];f.subVectors(e,i),u.setFromPoints(f,s);const p=n[3],d=r[3];p.subVectors(i,t),d.setFromPoints(p,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}Ot.prototype.closestPointToSegment=function(){const h=new M,t=new M,e=new te;return function(s,n=null,r=null){const{start:o,end:a}=s,c=this.points;let l,f=1/0;for(let u=0;u<3;u++){const p=(u+1)%3;e.start.copy(c[u]),e.end.copy(c[p]),Er(e,s,h,t),l=h.distanceToSquared(t),l<f&&(f=l,n&&n.copy(h),r&&r.copy(t))}return this.closestPointToPoint(o,h),l=o.distanceToSquared(h),l<f&&(f=l,n&&n.copy(h),r&&r.copy(o)),this.closestPointToPoint(a,h),l=a.distanceToSquared(h),l<f&&(f=l,n&&n.copy(h),r&&r.copy(a)),Math.sqrt(f)}}(),Ot.prototype.intersectsTriangle=function(){const h=new Ot,t=new Array(3),e=new Array(3),i=new ie,s=new ie,n=new M,r=new M,o=new M,a=new M,c=new M,l=new te,f=new te,u=new te,p=new M;function d(y,m,x){const g=y.points;let w=0,b=-1;for(let v=0;v<3;v++){const{start:S,end:A}=l;S.copy(g[v]),A.copy(g[(v+1)%3]),l.delta(r);const _=Rr(m.distanceToPoint(S));if(Rr(m.normal.dot(r))&&_){x.copy(l),w=2;break}const z=m.intersectLine(l,p);if(!z&&_&&p.copy(S),(z||_)&&!Rr(p.distanceTo(A))){if(w<=1)(w===1?x.start:x.end).copy(p),_&&(b=w);else if(w>=2){(b===1?x.start:x.end).copy(p),w=2;break}if(w++,w===2&&b===-1)break}}return w}return function(m,x=null,g=!1){this.needsUpdate&&this.update(),m.isExtendedTriangle?m.needsUpdate&&m.update():(h.copy(m),h.update(),m=h);const w=this.plane,b=m.plane;if(Math.abs(w.normal.dot(b.normal))>1-1e-10){const v=this.satBounds,S=this.satAxes;e[0]=m.a,e[1]=m.b,e[2]=m.c;for(let z=0;z<4;z++){const T=v[z],I=S[z];if(i.setFromPoints(I,e),T.isSeparated(i))return!1}const A=m.satBounds,_=m.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let z=0;z<4;z++){const T=A[z],I=_[z];if(i.setFromPoints(I,t),T.isSeparated(i))return!1}for(let z=0;z<4;z++){const T=S[z];for(let I=0;I<4;I++){const C=_[I];if(n.crossVectors(T,C),i.setFromPoints(n,t),s.setFromPoints(n,e),i.isSeparated(s))return!1}}return x&&(g||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),x.start.set(0,0,0),x.end.set(0,0,0)),!0}else{const v=d(this,b,f);if(v===1&&m.containsPoint(f.end))return x&&(x.start.copy(f.end),x.end.copy(f.end)),!0;if(v!==2)return!1;const S=d(m,w,u);if(S===1&&this.containsPoint(u.end))return x&&(x.start.copy(u.end),x.end.copy(u.end)),!0;if(S!==2)return!1;if(f.delta(o),u.delta(a),o.dot(a)<0){let B=u.start;u.start=u.end,u.end=B}const A=f.start.dot(o),_=f.end.dot(o),z=u.start.dot(o),T=u.end.dot(o),I=_<z,C=A<T;return A!==T&&z!==_&&I===C?!1:(x&&(c.subVectors(f.start,u.start),c.dot(o)>0?x.start.copy(f.start):x.start.copy(u.start),c.subVectors(f.end,u.end),c.dot(o)<0?x.end.copy(f.end):x.end.copy(u.end)),!0)}}}(),Ot.prototype.distanceToPoint=function(){const h=new M;return function(e){return this.closestPointToPoint(e,h),e.distanceTo(h)}}(),Ot.prototype.distanceToTriangle=function(){const h=new M,t=new M,e=["a","b","c"],i=new te,s=new te;return function(r,o=null,a=null){const c=o||a?i:null;if(this.intersectsTriangle(r,c))return(o||a)&&(o&&c.getCenter(o),a&&c.getCenter(a)),0;let l=1/0;for(let f=0;f<3;f++){let u;const p=e[f],d=r[p];this.closestPointToPoint(d,h),u=d.distanceToSquared(h),u<l&&(l=u,o&&o.copy(h),a&&a.copy(d));const y=this[p];r.closestPointToPoint(y,h),u=y.distanceToSquared(h),u<l&&(l=u,o&&o.copy(y),a&&a.copy(h))}for(let f=0;f<3;f++){const u=e[f],p=e[(f+1)%3];i.set(this[u],this[p]);for(let d=0;d<3;d++){const y=e[d],m=e[(d+1)%3];s.set(r[y],r[m]),Er(i,s,h,t);const x=h.distanceToSquared(t);x<l&&(l=x,o&&o.copy(h),a&&a.copy(t))}}return Math.sqrt(l)}}();class wt{constructor(t,e,i){this.isOrientedBox=!0,this.min=new M,this.max=new M,this.matrix=new N,this.invMatrix=new N,this.points=new Array(8).fill().map(()=>new M),this.satAxes=new Array(3).fill().map(()=>new M),this.satBounds=new Array(3).fill().map(()=>new ie),this.alignedSatBounds=new Array(3).fill().map(()=>new ie),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),i&&this.matrix.copy(i)}set(t,e,i){this.min.copy(t),this.max.copy(e),this.matrix.copy(i),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}wt.prototype.update=function(){return function(){const t=this.matrix,e=this.min,i=this.max,s=this.points;for(let c=0;c<=1;c++)for(let l=0;l<=1;l++)for(let f=0;f<=1;f++){const u=1*c|2*l|4*f,p=s[u];p.x=c?i.x:e.x,p.y=l?i.y:e.y,p.z=f?i.z:e.z,p.applyMatrix4(t)}const n=this.satBounds,r=this.satAxes,o=s[0];for(let c=0;c<3;c++){const l=r[c],f=n[c],u=1<<c,p=s[u];l.subVectors(o,p),f.setFromPoints(l,s)}const a=this.alignedSatBounds;a[0].setFromPointsField(s,"x"),a[1].setFromPointsField(s,"y"),a[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),wt.prototype.intersectsBox=function(){const h=new ie;return function(e){this.needsUpdate&&this.update();const i=e.min,s=e.max,n=this.satBounds,r=this.satAxes,o=this.alignedSatBounds;if(h.min=i.x,h.max=s.x,o[0].isSeparated(h)||(h.min=i.y,h.max=s.y,o[1].isSeparated(h))||(h.min=i.z,h.max=s.z,o[2].isSeparated(h)))return!1;for(let a=0;a<3;a++){const c=r[a],l=n[a];if(h.setFromBox(c,e),l.isSeparated(h))return!1}return!0}}(),wt.prototype.intersectsTriangle=function(){const h=new Ot,t=new Array(3),e=new ie,i=new ie,s=new M;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(h.copy(r),h.update(),r=h);const o=this.satBounds,a=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let u=0;u<3;u++){const p=o[u],d=a[u];if(e.setFromPoints(d,t),p.isSeparated(e))return!1}const c=r.satBounds,l=r.satAxes,f=this.points;for(let u=0;u<3;u++){const p=c[u],d=l[u];if(e.setFromPoints(d,f),p.isSeparated(e))return!1}for(let u=0;u<3;u++){const p=a[u];for(let d=0;d<4;d++){const y=l[d];if(s.crossVectors(p,y),e.setFromPoints(s,t),i.setFromPoints(s,f),e.isSeparated(i))return!1}}return!0}}(),wt.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),wt.prototype.distanceToPoint=function(){const h=new M;return function(e){return this.closestPointToPoint(e,h),e.distanceTo(h)}}(),wt.prototype.distanceToBox=function(){const h=["x","y","z"],t=new Array(12).fill().map(()=>new te),e=new Array(12).fill().map(()=>new te),i=new M,s=new M;return function(r,o=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||c)&&(r.getCenter(s),this.closestPointToPoint(s,i),r.closestPointToPoint(i,s),a&&a.copy(i),c&&c.copy(s)),0;const l=o*o,f=r.min,u=r.max,p=this.points;let d=1/0;for(let m=0;m<8;m++){const x=p[m];s.copy(x).clamp(f,u);const g=x.distanceToSquared(s);if(g<d&&(d=g,a&&a.copy(x),c&&c.copy(s),g<l))return Math.sqrt(g)}let y=0;for(let m=0;m<3;m++)for(let x=0;x<=1;x++)for(let g=0;g<=1;g++){const w=(m+1)%3,b=(m+2)%3,v=x<<w|g<<b,S=1<<m|x<<w|g<<b,A=p[v],_=p[S];t[y].set(A,_);const T=h[m],I=h[w],C=h[b],B=e[y],F=B.start,O=B.end;F[T]=f[T],F[I]=x?f[I]:u[I],F[C]=g?f[C]:u[I],O[T]=u[T],O[I]=x?f[I]:u[I],O[C]=g?f[C]:u[I],y++}for(let m=0;m<=1;m++)for(let x=0;x<=1;x++)for(let g=0;g<=1;g++){s.x=m?u.x:f.x,s.y=x?u.y:f.y,s.z=g?u.z:f.z,this.closestPointToPoint(s,i);const w=s.distanceToSquared(i);if(w<d&&(d=w,a&&a.copy(i),c&&c.copy(s),w<l))return Math.sqrt(w)}for(let m=0;m<12;m++){const x=t[m];for(let g=0;g<12;g++){const w=e[g];Er(x,w,i,s);const b=i.distanceToSquared(s);if(b<d&&(d=b,a&&a.copy(i),c&&c.copy(s),b<l))return Math.sqrt(b)}}return Math.sqrt(d)}}();class Lr{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Bl extends Lr{constructor(){super(()=>new Ot)}}const Pt=new Bl;class Pl{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=i=>{e&&t.push(e),e=i,this.float32Array=new Float32Array(i),this.uint16Array=new Uint16Array(i),this.uint32Array=new Uint32Array(i)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const Z=new Pl;let xe,ni;const ri=[],Xs=new Lr(()=>new Y);function Fl(h,t,e,i,s,n){xe=Xs.getPrimitive(),ni=Xs.getPrimitive(),ri.push(xe,ni),Z.setBuffer(h._roots[t]);const r=Or(0,h.geometry,e,i,s,n);Z.clearBuffer(),Xs.releasePrimitive(xe),Xs.releasePrimitive(ni),ri.pop(),ri.pop();const o=ri.length;return o>0&&(ni=ri[o-1],xe=ri[o-2]),r}function Or(h,t,e,i,s=null,n=0,r=0){const{float32Array:o,uint16Array:a,uint32Array:c}=Z;let l=h*2;if(vt(l,a)){const u=zt(h,c),p=Ct(l,a);return K(h,o,xe),i(u,p,!1,r,n+h,xe)}else{let T=function(C){const{uint16Array:B,uint32Array:F}=Z;let O=C*2;for(;!vt(O,B);)C=It(C),O=C*2;return zt(C,F)},I=function(C){const{uint16Array:B,uint32Array:F}=Z;let O=C*2;for(;!vt(O,B);)C=Bt(C,F),O=C*2;return zt(C,F)+Ct(O,B)};const u=It(h),p=Bt(h,c);let d=u,y=p,m,x,g,w;if(s&&(g=xe,w=ni,K(d,o,g),K(y,o,w),m=s(g),x=s(w),x<m)){d=p,y=u;const C=m;m=x,x=C,g=w}g||(g=xe,K(d,o,g));const b=vt(d*2,a),v=e(g,b,m,r+1,n+d);let S;if(v===Ia){const C=T(d),F=I(d)-C;S=i(C,F,!0,r+1,n+d,g)}else S=v&&Or(d,t,e,i,s,n,r+1);if(S)return!0;w=ni,K(y,o,w);const A=vt(y*2,a),_=e(w,A,x,r+1,n+y);let z;if(_===Ia){const C=T(y),F=I(y)-C;z=i(C,F,!0,r+1,n+y,w)}else z=_&&Or(y,t,e,i,s,n,r+1);return!!z}}const Li=new M,Nr=new M;function kl(h,t,e={},i=0,s=1/0){const n=i*i,r=s*s;let o=1/0,a=null;if(h.shapecast({boundsTraverseOrder:l=>(Li.copy(t).clamp(l.min,l.max),Li.distanceToSquared(t)),intersectsBounds:(l,f,u)=>u<o&&u<r,intersectsTriangle:(l,f)=>{l.closestPointToPoint(t,Li);const u=t.distanceToSquared(Li);return u<o&&(Nr.copy(Li),o=u,a=f),u<n}}),o===1/0)return null;const c=Math.sqrt(o);return e.point?e.point.copy(Nr):e.point=Nr.clone(),e.distance=c,e.faceIndex=a,e}const El=parseInt(Gi)>=169,Ie=new M,Be=new M,Pe=new M,Zs=new P,Ys=new P,Qs=new P,Da=new M,Va=new M,Ua=new M,Oi=new M;function Rl(h,t,e,i,s,n,r,o){let a;if(n===1?a=h.intersectTriangle(i,e,t,!0,s):a=h.intersectTriangle(t,e,i,n!==2,s),a===null)return null;const c=h.origin.distanceTo(s);return c<r||c>o?null:{distance:c,point:s.clone()}}function Ll(h,t,e,i,s,n,r,o,a,c,l){Ie.fromBufferAttribute(t,n),Be.fromBufferAttribute(t,r),Pe.fromBufferAttribute(t,o);const f=Rl(h,Ie,Be,Pe,Oi,a,c,l);if(f){const u=new M;ot.getBarycoord(Oi,Ie,Be,Pe,u),i&&(Zs.fromBufferAttribute(i,n),Ys.fromBufferAttribute(i,r),Qs.fromBufferAttribute(i,o),f.uv=ot.getInterpolation(Oi,Ie,Be,Pe,Zs,Ys,Qs,new P)),s&&(Zs.fromBufferAttribute(s,n),Ys.fromBufferAttribute(s,r),Qs.fromBufferAttribute(s,o),f.uv1=ot.getInterpolation(Oi,Ie,Be,Pe,Zs,Ys,Qs,new P)),e&&(Da.fromBufferAttribute(e,n),Va.fromBufferAttribute(e,r),Ua.fromBufferAttribute(e,o),f.normal=ot.getInterpolation(Oi,Ie,Be,Pe,Da,Va,Ua,new M),f.normal.dot(h.direction)>0&&f.normal.multiplyScalar(-1));const p={a:n,b:r,c:o,normal:new M,materialIndex:0};ot.getNormal(Ie,Be,Pe,p.normal),f.face=p,f.faceIndex=n,El&&(f.barycoord=u)}return f}function Ks(h,t,e,i,s,n,r){const o=i*3;let a=o+0,c=o+1,l=o+2;const f=h.index;h.index&&(a=f.getX(a),c=f.getX(c),l=f.getX(l));const{position:u,normal:p,uv:d,uv1:y}=h.attributes,m=Ll(e,u,p,d,y,a,c,l,t,n,r);return m?(m.faceIndex=i,s&&s.push(m),m):null}function st(h,t,e,i){const s=h.a,n=h.b,r=h.c;let o=t,a=t+1,c=t+2;e&&(o=e.getX(o),a=e.getX(a),c=e.getX(c)),s.x=i.getX(o),s.y=i.getY(o),s.z=i.getZ(o),n.x=i.getX(a),n.y=i.getY(a),n.z=i.getZ(a),r.x=i.getX(c),r.y=i.getY(c),r.z=i.getZ(c)}function Ol(h,t,e,i,s,n,r,o){const{geometry:a,_indirectBuffer:c}=h;for(let l=i,f=i+s;l<f;l++)Ks(a,t,e,l,n,r,o)}function Nl(h,t,e,i,s,n,r){const{geometry:o,_indirectBuffer:a}=h;let c=1/0,l=null;for(let f=i,u=i+s;f<u;f++){let p;p=Ks(o,t,e,f,null,n,r),p&&p.distance<c&&(l=p,c=p.distance)}return l}function Dl(h,t,e,i,s,n,r){const{geometry:o}=e,{index:a}=o,c=o.attributes.position;for(let l=h,f=t+h;l<f;l++){let u;if(u=l,st(r,u*3,a,c),r.needsUpdate=!0,i(r,u,s,n))return!0}return!1}function Vl(h,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=h.geometry,i=e.index?e.index.array:null,s=e.attributes.position;let n,r,o,a,c=0;const l=h._roots;for(let u=0,p=l.length;u<p;u++)n=l[u],r=new Uint32Array(n),o=new Uint16Array(n),a=new Float32Array(n),f(0,c),c+=n.byteLength;function f(u,p,d=!1){const y=u*2;if(o[y+15]===Hs){const x=r[u+6],g=o[y+14];let w=1/0,b=1/0,v=1/0,S=-1/0,A=-1/0,_=-1/0;for(let z=3*x,T=3*(x+g);z<T;z++){let I=i[z];const C=s.getX(I),B=s.getY(I),F=s.getZ(I);C<w&&(w=C),C>S&&(S=C),B<b&&(b=B),B>A&&(A=B),F<v&&(v=F),F>_&&(_=F)}return a[u+0]!==w||a[u+1]!==b||a[u+2]!==v||a[u+3]!==S||a[u+4]!==A||a[u+5]!==_?(a[u+0]=w,a[u+1]=b,a[u+2]=v,a[u+3]=S,a[u+4]=A,a[u+5]=_,!0):!1}else{const x=u+8,g=r[u+6],w=x+p,b=g+p;let v=d,S=!1,A=!1;t?v||(S=t.has(w),A=t.has(b),v=!S&&!A):(S=!0,A=!0);const _=v||S,z=v||A;let T=!1;_&&(T=f(x,p,v));let I=!1;z&&(I=f(g,p,v));const C=T||I;if(C)for(let B=0;B<3;B++){const F=x+B,O=g+B,D=a[F],et=a[F+3],lt=a[O],G=a[O+3];a[u+B]=D<lt?D:lt,a[u+B+3]=et>G?et:G}return C}}}function ge(h,t,e,i,s){let n,r,o,a,c,l;const f=1/e.direction.x,u=1/e.direction.y,p=1/e.direction.z,d=e.origin.x,y=e.origin.y,m=e.origin.z;let x=t[h],g=t[h+3],w=t[h+1],b=t[h+3+1],v=t[h+2],S=t[h+3+2];return f>=0?(n=(x-d)*f,r=(g-d)*f):(n=(g-d)*f,r=(x-d)*f),u>=0?(o=(w-y)*u,a=(b-y)*u):(o=(b-y)*u,a=(w-y)*u),n>a||o>r||((o>n||isNaN(n))&&(n=o),(a<r||isNaN(r))&&(r=a),p>=0?(c=(v-m)*p,l=(S-m)*p):(c=(S-m)*p,l=(v-m)*p),n>l||c>r)?!1:((c>n||n!==n)&&(n=c),(l<r||r!==r)&&(r=l),n<=s&&r>=i)}function Ul(h,t,e,i,s,n,r,o){const{geometry:a,_indirectBuffer:c}=h;for(let l=i,f=i+s;l<f;l++){let u=c?c[l]:l;Ks(a,t,e,u,n,r,o)}}function Wl(h,t,e,i,s,n,r){const{geometry:o,_indirectBuffer:a}=h;let c=1/0,l=null;for(let f=i,u=i+s;f<u;f++){let p;p=Ks(o,t,e,a?a[f]:f,null,n,r),p&&p.distance<c&&(l=p,c=p.distance)}return l}function ql(h,t,e,i,s,n,r){const{geometry:o}=e,{index:a}=o,c=o.attributes.position;for(let l=h,f=t+h;l<f;l++){let u;if(u=e.resolveTriangleIndex(l),st(r,u*3,a,c),r.needsUpdate=!0,i(r,u,s,n))return!0}return!1}function Hl(h,t,e,i,s,n,r){Z.setBuffer(h._roots[t]),Dr(0,h,e,i,s,n,r),Z.clearBuffer()}function Dr(h,t,e,i,s,n,r){const{float32Array:o,uint16Array:a,uint32Array:c}=Z,l=h*2;if(vt(l,a)){const u=zt(h,c),p=Ct(l,a);Ol(t,e,i,u,p,s,n,r)}else{const u=It(h);ge(u,o,i,n,r)&&Dr(u,t,e,i,s,n,r);const p=Bt(h,c);ge(p,o,i,n,r)&&Dr(p,t,e,i,s,n,r)}}const Jl=["x","y","z"];function Gl(h,t,e,i,s,n){Z.setBuffer(h._roots[t]);const r=Vr(0,h,e,i,s,n);return Z.clearBuffer(),r}function Vr(h,t,e,i,s,n){const{float32Array:r,uint16Array:o,uint32Array:a}=Z;let c=h*2;if(vt(c,o)){const f=zt(h,a),u=Ct(c,o);return Nl(t,e,i,f,u,s,n)}else{const f=La(h,a),u=Jl[f],d=i.direction[u]>=0;let y,m;d?(y=It(h),m=Bt(h,a)):(y=Bt(h,a),m=It(h));const g=ge(y,r,i,s,n)?Vr(y,t,e,i,s,n):null;if(g){const v=g.point[u];if(d?v<=r[m+f]:v>=r[m+f+3])return g}const b=ge(m,r,i,s,n)?Vr(m,t,e,i,s,n):null;return g&&b?g.distance<=b.distance?g:b:g||b||null}}const js=new Y,oi=new Ot,ai=new Ot,Ni=new N,Wa=new wt,tn=new wt;function $l(h,t,e,i){Z.setBuffer(h._roots[t]);const s=Ur(0,h,e,i);return Z.clearBuffer(),s}function Ur(h,t,e,i,s=null){const{float32Array:n,uint16Array:r,uint32Array:o}=Z;let a=h*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),Wa.set(e.boundingBox.min,e.boundingBox.max,i),s=Wa),vt(a,r)){const l=t.geometry,f=l.index,u=l.attributes.position,p=e.index,d=e.attributes.position,y=zt(h,o),m=Ct(a,r);if(Ni.copy(i).invert(),e.boundsTree)return K(h,n,tn),tn.matrix.copy(Ni),tn.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>tn.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(i),g.b.applyMatrix4(i),g.c.applyMatrix4(i),g.needsUpdate=!0;for(let w=y*3,b=(m+y)*3;w<b;w+=3)if(st(ai,w,f,u),ai.needsUpdate=!0,g.intersectsTriangle(ai))return!0;return!1}});for(let x=y*3,g=(m+y)*3;x<g;x+=3){st(oi,x,f,u),oi.a.applyMatrix4(Ni),oi.b.applyMatrix4(Ni),oi.c.applyMatrix4(Ni),oi.needsUpdate=!0;for(let w=0,b=p.count;w<b;w+=3)if(st(ai,w,p,d),ai.needsUpdate=!0,oi.intersectsTriangle(ai))return!0}}else{const l=h+8,f=o[h+6];return K(l,n,js),!!(s.intersectsBox(js)&&Ur(l,t,e,i,s)||(K(f,n,js),s.intersectsBox(js)&&Ur(f,t,e,i,s)))}}const en=new N,Wr=new wt,Di=new wt,Xl=new M,Zl=new M,Yl=new M,Ql=new M;function Kl(h,t,e,i={},s={},n=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Wr.set(t.boundingBox.min,t.boundingBox.max,e),Wr.needsUpdate=!0;const o=h.geometry,a=o.attributes.position,c=o.index,l=t.attributes.position,f=t.index,u=Pt.getPrimitive(),p=Pt.getPrimitive();let d=Xl,y=Zl,m=null,x=null;s&&(m=Yl,x=Ql);let g=1/0,w=null,b=null;return en.copy(e).invert(),Di.matrix.copy(en),h.shapecast({boundsTraverseOrder:v=>Wr.distanceToBox(v),intersectsBounds:(v,S,A)=>A<g&&A<r?(S&&(Di.min.copy(v.min),Di.max.copy(v.max),Di.needsUpdate=!0),!0):!1,intersectsRange:(v,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:_=>Di.distanceToBox(_),intersectsBounds:(_,z,T)=>T<g&&T<r,intersectsRange:(_,z)=>{for(let T=_,I=_+z;T<I;T++){st(p,3*T,f,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let C=v,B=v+S;C<B;C++){st(u,3*C,c,a),u.needsUpdate=!0;const F=u.distanceToTriangle(p,d,m);if(F<g&&(y.copy(d),x&&x.copy(m),g=F,w=C,b=T),F<n)return!0}}}});{const A=si(t);for(let _=0,z=A;_<z;_++){st(p,3*_,f,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let T=v,I=v+S;T<I;T++){st(u,3*T,c,a),u.needsUpdate=!0;const C=u.distanceToTriangle(p,d,m);if(C<g&&(y.copy(d),x&&x.copy(m),g=C,w=T,b=_),C<n)return!0}}}}}),Pt.releasePrimitive(u),Pt.releasePrimitive(p),g===1/0?null:(i.point?i.point.copy(y):i.point=y.clone(),i.distance=g,i.faceIndex=w,s&&(s.point?s.point.copy(x):s.point=x.clone(),s.point.applyMatrix4(en),y.applyMatrix4(en),s.distance=y.sub(s.point).length(),s.faceIndex=b),i)}function jl(h,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=h.geometry,i=e.index?e.index.array:null,s=e.attributes.position;let n,r,o,a,c=0;const l=h._roots;for(let u=0,p=l.length;u<p;u++)n=l[u],r=new Uint32Array(n),o=new Uint16Array(n),a=new Float32Array(n),f(0,c),c+=n.byteLength;function f(u,p,d=!1){const y=u*2;if(o[y+15]===Hs){const x=r[u+6],g=o[y+14];let w=1/0,b=1/0,v=1/0,S=-1/0,A=-1/0,_=-1/0;for(let z=x,T=x+g;z<T;z++){const I=3*h.resolveTriangleIndex(z);for(let C=0;C<3;C++){let B=I+C;B=i?i[B]:B;const F=s.getX(B),O=s.getY(B),D=s.getZ(B);F<w&&(w=F),F>S&&(S=F),O<b&&(b=O),O>A&&(A=O),D<v&&(v=D),D>_&&(_=D)}}return a[u+0]!==w||a[u+1]!==b||a[u+2]!==v||a[u+3]!==S||a[u+4]!==A||a[u+5]!==_?(a[u+0]=w,a[u+1]=b,a[u+2]=v,a[u+3]=S,a[u+4]=A,a[u+5]=_,!0):!1}else{const x=u+8,g=r[u+6],w=x+p,b=g+p;let v=d,S=!1,A=!1;t?v||(S=t.has(w),A=t.has(b),v=!S&&!A):(S=!0,A=!0);const _=v||S,z=v||A;let T=!1;_&&(T=f(x,p,v));let I=!1;z&&(I=f(g,p,v));const C=T||I;if(C)for(let B=0;B<3;B++){const F=x+B,O=g+B,D=a[F],et=a[F+3],lt=a[O],G=a[O+3];a[u+B]=D<lt?D:lt,a[u+B+3]=et>G?et:G}return C}}}function tu(h,t,e,i,s,n,r){Z.setBuffer(h._roots[t]),qr(0,h,e,i,s,n,r),Z.clearBuffer()}function qr(h,t,e,i,s,n,r){const{float32Array:o,uint16Array:a,uint32Array:c}=Z,l=h*2;if(vt(l,a)){const u=zt(h,c),p=Ct(l,a);Ul(t,e,i,u,p,s,n,r)}else{const u=It(h);ge(u,o,i,n,r)&&qr(u,t,e,i,s,n,r);const p=Bt(h,c);ge(p,o,i,n,r)&&qr(p,t,e,i,s,n,r)}}const eu=["x","y","z"];function iu(h,t,e,i,s,n){Z.setBuffer(h._roots[t]);const r=Hr(0,h,e,i,s,n);return Z.clearBuffer(),r}function Hr(h,t,e,i,s,n){const{float32Array:r,uint16Array:o,uint32Array:a}=Z;let c=h*2;if(vt(c,o)){const f=zt(h,a),u=Ct(c,o);return Wl(t,e,i,f,u,s,n)}else{const f=La(h,a),u=eu[f],d=i.direction[u]>=0;let y,m;d?(y=It(h),m=Bt(h,a)):(y=Bt(h,a),m=It(h));const g=ge(y,r,i,s,n)?Hr(y,t,e,i,s,n):null;if(g){const v=g.point[u];if(d?v<=r[m+f]:v>=r[m+f+3])return g}const b=ge(m,r,i,s,n)?Hr(m,t,e,i,s,n):null;return g&&b?g.distance<=b.distance?g:b:g||b||null}}const sn=new Y,hi=new Ot,ci=new Ot,Vi=new N,qa=new wt,nn=new wt;function su(h,t,e,i){Z.setBuffer(h._roots[t]);const s=Jr(0,h,e,i);return Z.clearBuffer(),s}function Jr(h,t,e,i,s=null){const{float32Array:n,uint16Array:r,uint32Array:o}=Z;let a=h*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),qa.set(e.boundingBox.min,e.boundingBox.max,i),s=qa),vt(a,r)){const l=t.geometry,f=l.index,u=l.attributes.position,p=e.index,d=e.attributes.position,y=zt(h,o),m=Ct(a,r);if(Vi.copy(i).invert(),e.boundsTree)return K(h,n,nn),nn.matrix.copy(Vi),nn.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:g=>nn.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(i),g.b.applyMatrix4(i),g.c.applyMatrix4(i),g.needsUpdate=!0;for(let w=y,b=m+y;w<b;w++)if(st(ci,3*t.resolveTriangleIndex(w),f,u),ci.needsUpdate=!0,g.intersectsTriangle(ci))return!0;return!1}});for(let x=y,g=m+y;x<g;x++){const w=t.resolveTriangleIndex(x);st(hi,3*w,f,u),hi.a.applyMatrix4(Vi),hi.b.applyMatrix4(Vi),hi.c.applyMatrix4(Vi),hi.needsUpdate=!0;for(let b=0,v=p.count;b<v;b+=3)if(st(ci,b,p,d),ci.needsUpdate=!0,hi.intersectsTriangle(ci))return!0}}else{const l=h+8,f=o[h+6];return K(l,n,sn),!!(s.intersectsBox(sn)&&Jr(l,t,e,i,s)||(K(f,n,sn),s.intersectsBox(sn)&&Jr(f,t,e,i,s)))}}const rn=new N,Gr=new wt,Ui=new wt,nu=new M,ru=new M,ou=new M,au=new M;function hu(h,t,e,i={},s={},n=0,r=1/0){t.boundingBox||t.computeBoundingBox(),Gr.set(t.boundingBox.min,t.boundingBox.max,e),Gr.needsUpdate=!0;const o=h.geometry,a=o.attributes.position,c=o.index,l=t.attributes.position,f=t.index,u=Pt.getPrimitive(),p=Pt.getPrimitive();let d=nu,y=ru,m=null,x=null;s&&(m=ou,x=au);let g=1/0,w=null,b=null;return rn.copy(e).invert(),Ui.matrix.copy(rn),h.shapecast({boundsTraverseOrder:v=>Gr.distanceToBox(v),intersectsBounds:(v,S,A)=>A<g&&A<r?(S&&(Ui.min.copy(v.min),Ui.max.copy(v.max),Ui.needsUpdate=!0),!0):!1,intersectsRange:(v,S)=>{if(t.boundsTree){const A=t.boundsTree;return A.shapecast({boundsTraverseOrder:_=>Ui.distanceToBox(_),intersectsBounds:(_,z,T)=>T<g&&T<r,intersectsRange:(_,z)=>{for(let T=_,I=_+z;T<I;T++){const C=A.resolveTriangleIndex(T);st(p,3*C,f,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let B=v,F=v+S;B<F;B++){const O=h.resolveTriangleIndex(B);st(u,3*O,c,a),u.needsUpdate=!0;const D=u.distanceToTriangle(p,d,m);if(D<g&&(y.copy(d),x&&x.copy(m),g=D,w=B,b=T),D<n)return!0}}}})}else{const A=si(t);for(let _=0,z=A;_<z;_++){st(p,3*_,f,l),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let T=v,I=v+S;T<I;T++){const C=h.resolveTriangleIndex(T);st(u,3*C,c,a),u.needsUpdate=!0;const B=u.distanceToTriangle(p,d,m);if(B<g&&(y.copy(d),x&&x.copy(m),g=B,w=T,b=_),B<n)return!0}}}}}),Pt.releasePrimitive(u),Pt.releasePrimitive(p),g===1/0?null:(i.point?i.point.copy(y):i.point=y.clone(),i.distance=g,i.faceIndex=w,s&&(s.point?s.point.copy(x):s.point=x.clone(),s.point.applyMatrix4(rn),y.applyMatrix4(rn),s.distance=y.sub(s.point).length(),s.faceIndex=b),i)}function cu(){return typeof SharedArrayBuffer<"u"}const Wi=new Z.constructor,on=new Z.constructor,we=new Lr(()=>new Y),li=new Y,ui=new Y,$r=new Y,Xr=new Y;let Zr=!1;function lu(h,t,e,i){if(Zr)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Zr=!0;const s=h._roots,n=t._roots;let r,o=0,a=0;const c=new N().copy(e).invert();for(let l=0,f=s.length;l<f;l++){Wi.setBuffer(s[l]),a=0;const u=we.getPrimitive();K(0,Wi.float32Array,u),u.applyMatrix4(c);for(let p=0,d=n.length;p<d&&(on.setBuffer(n[p]),r=Nt(0,0,e,c,i,o,a,0,0,u),on.clearBuffer(),a+=n[p].length,!r);p++);if(we.releasePrimitive(u),Wi.clearBuffer(),o+=s[l].length,r)break}return Zr=!1,r}function Nt(h,t,e,i,s,n=0,r=0,o=0,a=0,c=null,l=!1){let f,u;l?(f=on,u=Wi):(f=Wi,u=on);const p=f.float32Array,d=f.uint32Array,y=f.uint16Array,m=u.float32Array,x=u.uint32Array,g=u.uint16Array,w=h*2,b=t*2,v=vt(w,y),S=vt(b,g);let A=!1;if(S&&v)l?A=s(zt(t,x),Ct(t*2,g),zt(h,d),Ct(h*2,y),a,r+t,o,n+h):A=s(zt(h,d),Ct(h*2,y),zt(t,x),Ct(t*2,g),o,n+h,a,r+t);else if(S){const _=we.getPrimitive();K(t,m,_),_.applyMatrix4(e);const z=It(h),T=Bt(h,d);K(z,p,li),K(T,p,ui);const I=_.intersectsBox(li),C=_.intersectsBox(ui);A=I&&Nt(t,z,i,e,s,r,n,a,o+1,_,!l)||C&&Nt(t,T,i,e,s,r,n,a,o+1,_,!l),we.releasePrimitive(_)}else{const _=It(t),z=Bt(t,x);K(_,m,$r),K(z,m,Xr);const T=c.intersectsBox($r),I=c.intersectsBox(Xr);if(T&&I)A=Nt(h,_,e,i,s,n,r,o,a+1,c,l)||Nt(h,z,e,i,s,n,r,o,a+1,c,l);else if(T)if(v)A=Nt(h,_,e,i,s,n,r,o,a+1,c,l);else{const C=we.getPrimitive();C.copy($r).applyMatrix4(e);const B=It(h),F=Bt(h,d);K(B,p,li),K(F,p,ui);const O=C.intersectsBox(li),D=C.intersectsBox(ui);A=O&&Nt(_,B,i,e,s,r,n,a,o+1,C,!l)||D&&Nt(_,F,i,e,s,r,n,a,o+1,C,!l),we.releasePrimitive(C)}else if(I)if(v)A=Nt(h,z,e,i,s,n,r,o,a+1,c,l);else{const C=we.getPrimitive();C.copy(Xr).applyMatrix4(e);const B=It(h),F=Bt(h,d);K(B,p,li),K(F,p,ui);const O=C.intersectsBox(li),D=C.intersectsBox(ui);A=O&&Nt(z,B,i,e,s,r,n,a,o+1,C,!l)||D&&Nt(z,F,i,e,s,r,n,a,o+1,C,!l),we.releasePrimitive(C)}}return A}const an=new wt,Ha=new Y,uu={strategy:Ca,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class qi{static serialize(t,e={}){e={cloneBuffers:!0,...e};const i=t.geometry,s=t._roots,n=t._indirectBuffer,r=i.getIndex();let o;return e.cloneBuffers?o={roots:s.map(a=>a.slice()),index:r?r.array.slice():null,indirectBuffer:n?n.slice():null}:o={roots:s,index:r?r.array:null,indirectBuffer:n},o}static deserialize(t,e,i={}){i={setIndex:!0,indirect:!!t.indirectBuffer,...i};const{index:s,roots:n,indirectBuffer:r}=t,o=new qi(e,{...i,[Ir]:!0});if(o._roots=n,o._indirectBuffer=r||null,i.setIndex){const a=e.getIndex();if(a===null){const c=new xt(t.index,1,!1);e.setIndex(c)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return o}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...uu,[Ir]:!1},e),e.useSharedArrayBuffer&&!cu())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Ir]||(zl(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Y))),this.resolveTriangleIndex=e.indirect?i=>this._indirectBuffer[i]:i=>i}refit(t=null){return(this.indirect?jl:Vl)(this,t)}traverse(t,e=0){const i=this._roots[e],s=new Uint32Array(i),n=new Uint16Array(i);r(0);function r(o,a=0){const c=o*2,l=n[c+15]===Hs;if(l){const f=s[o+6],u=n[c+14];t(a,l,new Float32Array(i,o*4,6),f,u)}else{const f=o+ki/4,u=s[o+6],p=s[o+7];t(a,l,new Float32Array(i,o*4,6),p)||(r(f,a+1),r(u,a+1))}}}raycast(t,e=0,i=0,s=1/0){const n=this._roots,r=this.geometry,o=[],a=e.isMaterial,c=Array.isArray(e),l=r.groups,f=a?e.side:e,u=this.indirect?tu:Hl;for(let p=0,d=n.length;p<d;p++){const y=c?e[l[p].materialIndex].side:f,m=o.length;if(u(this,p,y,t,o,i,s),c){const x=l[p].materialIndex;for(let g=m,w=o.length;g<w;g++)o[g].face.materialIndex=x}}return o}raycastFirst(t,e=0,i=0,s=1/0){const n=this._roots,r=this.geometry,o=e.isMaterial,a=Array.isArray(e);let c=null;const l=r.groups,f=o?e.side:e,u=this.indirect?iu:Gl;for(let p=0,d=n.length;p<d;p++){const y=a?e[l[p].materialIndex].side:f,m=u(this,p,y,t,i,s);m!=null&&(c==null||m.distance<c.distance)&&(c=m,a&&(m.face.materialIndex=l[p].materialIndex))}return c}intersectsGeometry(t,e){let i=!1;const s=this._roots,n=this.indirect?su:$l;for(let r=0,o=s.length;r<o&&(i=n(this,r,t,e),!i);r++);return i}shapecast(t){const e=Pt.getPrimitive(),i=this.indirect?ql:Dl;let{boundsTraverseOrder:s,intersectsBounds:n,intersectsRange:r,intersectsTriangle:o}=t;if(r&&o){const f=r;r=(u,p,d,y,m)=>f(u,p,d,y,m)?!0:i(u,p,this,o,d,y,e)}else r||(o?r=(f,u,p,d)=>i(f,u,this,o,p,d,e):r=(f,u,p)=>p);let a=!1,c=0;const l=this._roots;for(let f=0,u=l.length;f<u;f++){const p=l[f];if(a=Fl(this,f,n,r,s,c),a)break;c+=p.byteLength}return Pt.releasePrimitive(e),a}bvhcast(t,e,i){let{intersectsRanges:s,intersectsTriangles:n}=i;const r=Pt.getPrimitive(),o=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?d=>{const y=this.resolveTriangleIndex(d);st(r,y*3,o,a)}:d=>{st(r,d*3,o,a)},l=Pt.getPrimitive(),f=t.geometry.index,u=t.geometry.attributes.position,p=t.indirect?d=>{const y=t.resolveTriangleIndex(d);st(l,y*3,f,u)}:d=>{st(l,d*3,f,u)};if(n){const d=(y,m,x,g,w,b,v,S)=>{for(let A=x,_=x+g;A<_;A++){p(A),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let z=y,T=y+m;z<T;z++)if(c(z),r.needsUpdate=!0,n(r,l,z,A,w,b,v,S))return!0}return!1};if(s){const y=s;s=function(m,x,g,w,b,v,S,A){return y(m,x,g,w,b,v,S,A)?!0:d(m,x,g,w,b,v,S,A)}}else s=d}return lu(this,t,e,s)}intersectsBox(t,e){return an.set(t.min,t.max,e),an.needsUpdate=!0,this.shapecast({intersectsBounds:i=>an.intersectsBox(i),intersectsTriangle:i=>an.intersectsTriangle(i)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,i={},s={},n=0,r=1/0){return(this.indirect?hu:Kl)(this,t,e,i,s,n,r)}closestPointToPoint(t,e={},i=0,s=1/0){return kl(this,t,e,i,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(i=>{K(0,new Float32Array(i),Ha),t.union(Ha)}),t}}function Ja(h,t,e){return h===null?null:(h.point.applyMatrix4(t.matrixWorld),h.distance=h.point.distanceTo(e.ray.origin),h.object=t,h)}const fu=parseInt(Gi)>=166,hn=new Ve,Ga=new M,$a=new N,pu=Kt.prototype.raycast,du=_i.prototype.raycast,Xa=new M,ct=new Kt,cn=[];function Za(h,t){this.isBatchedMesh?mu.call(this,h,t):yu.call(this,h,t)}function mu(h,t){if(this.boundsTrees){const e=this.boundsTrees,i=this._drawInfo||this._instanceInfo,s=this._drawRanges||this._geometryInfo,n=this.matrixWorld;ct.material=this.material,ct.geometry=this.geometry;const r=ct.geometry.boundsTree,o=ct.geometry.drawRange;ct.geometry.boundingSphere===null&&(ct.geometry.boundingSphere=new ht);for(let a=0,c=i.length;a<c;a++){if(!this.getVisibleAt(a))continue;const l=i[a].geometryIndex;if(ct.geometry.boundsTree=e[l],this.getMatrixAt(a,ct.matrixWorld).premultiply(n),!ct.geometry.boundsTree){this.getBoundingBoxAt(l,ct.geometry.boundingBox),this.getBoundingSphereAt(l,ct.geometry.boundingSphere);const f=s[l];ct.geometry.setDrawRange(f.start,f.count)}ct.raycast(h,cn);for(let f=0,u=cn.length;f<u;f++){const p=cn[f];p.object=this,p.batchId=a,t.push(p)}cn.length=0}ct.geometry.boundsTree=r,ct.geometry.drawRange=o,ct.material=null,ct.geometry=null}else du.call(this,h,t)}function yu(h,t){if(this.geometry.boundsTree){if(this.material===void 0)return;$a.copy(this.matrixWorld).invert(),hn.copy(h.ray).applyMatrix4($a),Xa.setFromMatrixScale(this.matrixWorld),Ga.copy(hn.direction).multiply(Xa);const e=Ga.length(),i=h.near/e,s=h.far/e,n=this.geometry.boundsTree;if(h.firstHitOnly===!0){const r=Ja(n.raycastFirst(hn,this.material,i,s),this,h);r&&t.push(r)}else{const r=n.raycast(hn,this.material,i,s);for(let o=0,a=r.length;o<a;o++){const c=Ja(r[o],this,h);c&&t.push(c)}}}else pu.call(this,h,t)}function xu(h={}){return this.boundsTree=new qi(this,h),this.boundsTree}function gu(){this.boundsTree=null}function wu(h=-1,t={}){if(!fu)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");t.indirect&&console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'),t={...t,indirect:!1,range:null};const e=this._drawRanges||this._geometryInfo,i=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(i).fill(null));const s=this.boundsTrees;for(;s.length<i;)s.push(null);if(h<0){for(let n=0;n<i;n++)t.range=e[n],s[n]=new qi(this.geometry,t);return s}else return h<e.length&&(t.range=e[h],s[h]=new qi(this.geometry,t)),s[h]||null}function bu(h=-1){h<0?this.boundsTrees.fill(null):h<this.boundsTree.length&&(this.boundsTrees[h]=null)}$.prototype.computeBoundsTree=xu,$.prototype.disposeBoundsTree=gu,Kt.prototype.raycast=Za,_i.prototype.computeBoundsTree=wu,_i.prototype.disposeBoundsTree=bu,_i.prototype.raycast=Za;let fi=new Io,Mu=new ol,Hi=0,ln=1e9;self.addEventListener("message",h=>{if(h.data.type=="init"){if(h.data.total){ln=h.data.total,Hi==ln&&(fi.updateMatrixWorld(!0),self.postMessage(!0));return}Mu.parse(h.data.mesh,t=>{t.geometry.computeBoundsTree(),t.isInstancedMesh?(fi.add(t),++Hi,Hi==ln&&(fi.updateMatrixWorld(!0),self.postMessage(!0))):(new N().fromArray(h.data.transform).decompose(t.position,t.quaternion,t.scale),fi.add(t),++Hi,Hi==ln&&(fi.updateMatrixWorld(!0),self.postMessage(!0)))})}}),self.addEventListener("message",h=>{if(h.data.type!="raycast")return;let t=new hl,e=new M().fromArray(h.data.eye),i=new M().fromArray(h.data.dir);t.far=h.data.far,t.set(e,i),t.firstHitOnly=!0;let s=t.intersectObjects(fi.children,!0).length>0;self.postMessage({result:s,id:h.data.id})})})();
